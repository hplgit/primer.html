<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Files, strings, and dictionaries">
<meta name="keywords" content="dictionary,keys (dictionaries),immutable objects,mutable objects,dictionary comprehensions,nested dictionaries,dictionary nested,date conversion,plotting data vs date,string slicing,slicing,substrings,string substrings,string searching,string substitution,substitution (in text),string splitting,string case change,string testing for number,whitespace,blank lines in files,string stripping leading/trailing blanks,string joining list elements,frequency matrix,dictionary,dictionary functionality">

<title>Files, strings, and dictionaries</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u' Dictionaries ', 1, u'sec:files:dicts', u'sec:files:dicts'),
              (u' Making dictionaries ', 2, None, '___sec1'),
              (u' Dictionary operations ', 2, None, '___sec2'),
              (u' Remark ', 3, None, '___sec3'),
              (u' Example: Polynomials as dictionaries ',
               2,
               u'sec:files:poly',
               u'sec:files:poly'),
              (u' Dictionaries with default values and ordering ',
               2,
               u'sec:files:dict:default:order',
               u'sec:files:dict:default:order'),
              (u' Dictionaries with default values ', 3, None, '___sec6'),
              (u' Ordered dictionaries ', 3, None, '___sec7'),
              (u' Example: File data in dictionaries ',
               2,
               u'sec:files:dict:density',
               u'sec:files:dict:density'),
              (u' Problem ', 3, None, '___sec9'),
              (u' Solution ', 3, None, '___sec10'),
              (u' Example: File data in nested dictionaries ',
               2,
               u'sec:files:dictdict',
               u'sec:files:dictdict'),
              (u' Problem ', 3, None, '___sec12'),
              (u' Algorithm ', 3, None, '___sec13'),
              (u' Implementation ', 3, None, '___sec14'),
              (u' Dissection ', 3, None, '___sec15'),
              (u' Example: Reading and plotting data recorded at specific dates ',
               2,
               u'sec:files:stockprices',
               u'sec:files:stockprices'),
              (u' Problem ', 3, None, '___sec17'),
              (u' Solution ', 3, None, '___sec18'),
              (u' Strings ', 1, u'sec:files:str', u'sec:files:str'),
              (u' Common operations on strings ',
               2,
               u'sec:files:stringop',
               u'sec:files:stringop'),
              (u' Substring specification ', 3, None, '___sec21'),
              (u' Searching for substrings ', 3, None, '___sec22'),
              (u' Substitution ', 3, None, '___sec23'),
              (u' String splitting ', 3, None, '___sec24'),
              (u' Upper and lower case ', 3, None, '___sec25'),
              (u' Strings are constant ', 3, None, '___sec26'),
              (u' Strings with digits only ', 3, None, '___sec27'),
              (u' Whitespace ', 3, None, '___sec28'),
              (u' Joining strings ', 3, None, '___sec29'),
              (u' Example: Reading pairs of numbers ',
               2,
               u'sec:files:pairs',
               u'sec:files:pairs'),
              (u' Problem ', 3, None, '___sec31'),
              (u' Solution ', 3, None, '___sec32'),
              (u' Example: Reading coordinates ', 2, None, '___sec33'),
              (u' Problem ', 3, None, '___sec34'),
              (u' Solution 1: substring extraction ', 3, None, '___sec35'),
              (u' Solution 2: string search ', 3, None, '___sec36'),
              (u' Solution 3: string split ', 3, None, '___sec37'),
              (u' Reading data from web pages ',
               1,
               u'sec:files:webtxt',
               u'sec:files:webtxt'),
              (u' About web pages ',
               2,
               u'sec:files:HTMLintro',
               u'sec:files:HTMLintro'),
              (u' How to access web pages in programs ',
               2,
               u'sec:files:urllib',
               u'sec:files:urllib'),
              (u' Alternative 1 ', 3, None, '___sec41'),
              (u' Alternative 2 ', 3, None, '___sec42'),
              (u' Example: Reading pure text files ',
               2,
               u'sec:files:url:weather',
               u'sec:files:url:weather'),
              (u' Example: Extracting data from HTML ',
               2,
               u'sec:files:url:interpret',
               u'sec:files:url:interpret'),
              (u' Handling non-English text ',
               2,
               u'sec:files:encoding',
               u'sec:files:encoding'),
              (u' Reading and writing spreadsheet files ',
               1,
               u'sec:files:csv',
               u'sec:files:csv'),
              (u' CSV files ', 2, None, '___sec47'),
              (u' Reading CSV files ', 2, None, '___sec48'),
              (u' Processing spreadsheet data ', 2, None, '___sec49'),
              (u' Writing CSV files ', 2, None, '___sec50'),
              (u' Remark ', 3, None, '___sec51'),
              (u' Representing number cells with Numerical Python arrays ',
               2,
               None,
               '___sec52'),
              (u' Using more high-level Numerical Python functionality ',
               2,
               None,
               '___sec53'),
              (u' Examples from analyzing DNA ',
               1,
               u'bioinf:DNAanalysis',
               u'bioinf:DNAanalysis'),
              (u' Computing frequencies ',
               2,
               u'bioinf:freqm',
               u'bioinf:freqm'),
              (u' Separate frequency lists ', 3, None, '___sec56'),
              (u' Nested list ', 3, None, '___sec57'),
              (u' Dictionary for more convenient indexing ',
               3,
               None,
               '___sec58'),
              (u' Numerical Python array ', 3, None, '___sec59'),
              (u' Dictionary of lists ', 3, None, '___sec60'),
              (u' Dictionary of dictionaries ', 3, None, '___sec61'),
              (u' Using dictionaries with default values ',
               3,
               None,
               '___sec62'),
              (u' Using arrays and vectorization ', 3, None, '___sec63'),
              (u' Analyzing the frequency matrix ',
               2,
               u'bioinf:freq:analysis',
               u'bioinf:freq:analysis'),
              (u' List of lists frequency matrix ', 3, None, '___sec65'),
              (u' Dict of dicts frequency matrix ', 3, None, '___sec66'),
              (u' Finding base frequencies ',
               2,
               u'bioinf:basefreq',
               u'bioinf:basefreq'),
              (u' Translating genes into proteins ',
               2,
               u'bioinf:gene2protein',
               u'bioinf:gene2protein'),
              (u' Some humans can drink milk, while others cannot ',
               2,
               u'bioinf:lactase:milk',
               u'bioinf:lactase:milk'),
              (u' Summary ', 1, None, '___sec70'),
              (u' Chapter topics ', 2, None, '___sec71'),
              (u' Dictionaries ', 3, None, '___sec72'),
              (u' Strings ', 3, None, '___sec73'),
              (u' Downloading Internet files ', 3, None, '___sec74'),
              (u' Terminology ', 3, None, '___sec75'),
              (u' Example: A file database ',
               2,
               u'sec:files:sumex',
               u'sec:files:sumex'),
              (u' Problem ', 3, None, '___sec77'),
              (u' Solution ', 3, None, '___sec78'),
              (u' Exercises ',
               1,
               u'sec:files:exercises',
               u'sec:files:exercises'),
              (u' Exercise 1: Make a dictionary from a table ',
               2,
               u'sec:files:ex2b:basic',
               u'sec:files:ex2b:basic'),
              (u' Exercise 2: Explore syntax differences: lists vs. dicts ',
               2,
               u'sec:files:ex2',
               u'sec:files:ex2'),
              (u' Exercise 3: Use string operations to improve a program ',
               2,
               u'sec:files:ex17',
               u'sec:files:ex17'),
              (u' Exercise 4: Interpret output from a program ',
               2,
               u'sec:files:ex13',
               u'sec:files:ex13'),
              (u' Exercise 5: Make a dictionary ',
               2,
               u'sec:files:ex2b',
               u'sec:files:ex2b'),
              (u' Exercise 6: Make a nested dictionary ',
               2,
               u'sec:files:ex2c',
               u'sec:files:ex2c'),
              (u' Exercise 7: Make a nested dictionary from a file ',
               2,
               u'sec:files:ex2d:nested',
               u'sec:files:ex2d:nested'),
              (u' Exercise 8: Make a nested dictionary from a file ',
               2,
               u'sec:files:ex2d:nested2',
               u'sec:files:ex2d:nested2'),
              (u' Exercise 9: Compute the area of a triangle ',
               2,
               u'sec:files:ex2d',
               u'sec:files:ex2d'),
              (u' Exercise 10: Compare data structures for polynomials ',
               2,
               u'sec:files:ex16',
               u'sec:files:ex16'),
              (u' Exercise 11: Compute the derivative of a polynomial ',
               2,
               u'sec:files:ex3',
               u'sec:files:ex3'),
              (u' Exercise 12: Specify functions on the command line ',
               2,
               u'sec:basic:ex10',
               u'sec:basic:ex10'),
              (u' Exercise 13: Interpret function specifications ',
               2,
               u'sec:basic:ex10b',
               u'sec:basic:ex10b'),
              (u' Exercise 14: Compare average temperatures in cities ',
               2,
               u'sec:files:ex8',
               u'sec:files:ex8'),
              (u' Exercise 15: Generate an HTML report with figures ',
               2,
               u'sec:files:ex21',
               u'sec:files:ex21'),
              (u' Exercise 16: Allow different types for a function argument ',
               2,
               u'bioinf:exer:freq:fargs',
               u'bioinf:exer:freq:fargs'),
              (u' Exercise 17: Make a function more robust ',
               2,
               u'bioinf:exer:get_base_counts2',
               u'bioinf:exer:get_base_counts2'),
              (u' Exercise 18: Find proportion of bases inside/outside exons ',
               2,
               u'bioinf:exer:Ainsouts:exons',
               u'bioinf:exer:Ainsouts:exons'),
              (u' References ', 1, None, '___sec98')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="files-bootstrap.html">Files, strings, and dictionaries</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#sec:files:dicts" style="font-size: 80%;">Dictionaries</a></li>
     <!-- navigation toc: --> <li><a href="#sec:files:str" style="font-size: 80%;">Strings</a></li>
     <!-- navigation toc: --> <li><a href="#sec:files:webtxt" style="font-size: 80%;">Reading data from web pages</a></li>
     <!-- navigation toc: --> <li><a href="#sec:files:csv" style="font-size: 80%;">Reading and writing spreadsheet files</a></li>
     <!-- navigation toc: --> <li><a href="#bioinf:DNAanalysis" style="font-size: 80%;">Examples from analyzing DNA</a></li>
     <!-- navigation toc: --> <li><a href="#___sec70" style="font-size: 80%;">Summary</a></li>
     <!-- navigation toc: --> <li><a href="#sec:files:exercises" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#___sec98" style="font-size: 80%;">References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Files, strings, and dictionaries</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 31, 2014</h4></center> <!-- date -->

<h2>Table of contents</h2>

<a href="#sec:files:dicts"> Dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Making dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Dictionary operations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:poly"> Example: Polynomials as dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dict:default:order"> Dictionaries with default values and ordering </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Dictionaries with default values </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec7"> Ordered dictionaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dict:density"> Example: File data in dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec10"> Solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:dictdict"> Example: File data in nested dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec12"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> Algorithm </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec14"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> Dissection </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:stockprices"> Example: Reading and plotting data recorded at specific dates </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> Solution </a><br>
<a href="#sec:files:str"> Strings </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:stringop"> Common operations on strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec21"> Substring specification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Searching for substrings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec23"> Substitution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec24"> String splitting </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec25"> Upper and lower case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Strings are constant </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> Strings with digits only </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec28"> Whitespace </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Joining strings </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:pairs"> Example: Reading pairs of numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec31"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec32"> Solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> Example: Reading coordinates </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec35"> Solution 1: substring extraction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec36"> Solution 2: string search </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec37"> Solution 3: string split </a><br>
<a href="#sec:files:webtxt"> Reading data from web pages </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:HTMLintro"> About web pages </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:urllib"> How to access web pages in programs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec41"> Alternative 1 </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Alternative 2 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:url:weather"> Example: Reading pure text files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:url:interpret"> Example: Extracting data from HTML </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:encoding"> Handling non-English text </a><br>
<a href="#sec:files:csv"> Reading and writing spreadsheet files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> CSV files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Reading CSV files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Processing spreadsheet data </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Writing CSV files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Remark </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Representing number cells with Numerical Python arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Using more high-level Numerical Python functionality </a><br>
<a href="#bioinf:DNAanalysis"> Examples from analyzing DNA </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:freqm"> Computing frequencies </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec56"> Separate frequency lists </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec57"> Nested list </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec58"> Dictionary for more convenient indexing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec59"> Numerical Python array </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec60"> Dictionary of lists </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec61"> Dictionary of dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec62"> Using dictionaries with default values </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Using arrays and vectorization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:freq:analysis"> Analyzing the frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec65"> List of lists frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec66"> Dict of dicts frequency matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:basefreq"> Finding base frequencies </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:gene2protein"> Translating genes into proteins </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:lactase:milk"> Some humans can drink milk, while others cannot </a><br>
<a href="#___sec70"> Summary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec71"> Chapter topics </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec72"> Dictionaries </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec73"> Strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec74"> Downloading Internet files </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec75"> Terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:sumex"> Example: A file database </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec77"> Problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec78"> Solution </a><br>
<a href="#sec:files:exercises"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2b:basic"> Exercise 1: Make a dictionary from a table </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2"> Exercise 2: Explore syntax differences: lists vs. dicts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex17"> Exercise 3: Use string operations to improve a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex13"> Exercise 4: Interpret output from a program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2b"> Exercise 5: Make a dictionary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2c"> Exercise 6: Make a nested dictionary </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d:nested"> Exercise 7: Make a nested dictionary from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d:nested2"> Exercise 8: Make a nested dictionary from a file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex2d"> Exercise 9: Compute the area of a triangle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex16"> Exercise 10: Compare data structures for polynomials </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex3"> Exercise 11: Compute the derivative of a polynomial </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:ex10"> Exercise 12: Specify functions on the command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:basic:ex10b"> Exercise 13: Interpret function specifications </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex8"> Exercise 14: Compare average temperatures in cities </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:files:ex21"> Exercise 15: Generate an HTML report with figures </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:freq:fargs"> Exercise 16: Allow different types for a function argument </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:get_base_counts2"> Exercise 17: Make a function more robust </a><br>
&nbsp; &nbsp; &nbsp; <a href="#bioinf:exer:Ainsouts:exons"> Exercise 18: Find proportion of bases inside/outside exons </a><br>
<a href="#___sec98"> References </a><br>
</p>
<p>
<!-- Externaldocuments: ../formulas/main_formulas, ../looplist/main_looplist, ../funcif/main_funcif, ../input/main_input, ../plot/main_plot, ../class/main_class, ../random/main_random, ../oo/main_oo, ../diffeq/main_diffeq, ../discalc/main_discalc, ../ode1/main_ode1, ../boxspring/main_boxspring, ../ode2/main_ode2, ../debug/main_debug, ../cython/main_cython, ../tech/main_timing, ../tech/main_varargs, ../tech/main_runpy, ../tech/main_ostasks, ../tech/main_accesspy, ../tech/main_nose -->

<p>
<a name="ch:files"></a>

<p>
The present chapter addresses many techniques for interpreting
information in files and storing the data in convenient Python objects
for further data analysis. A particularly handy object for many
purposes is the dictionary, which maps objects to objects, very often
strings to various kinds of data that later can be looked up through
the strings.  The section <a href="#sec:files:dicts">Dictionaries</a> is devoted to dictionaries.

<p>
Information in files often appear as pure text, so to interpret and
extract data from files it is sometimes necessary to carry out
sophisticated operations on the text.  Python strings have many
methods for performing such operations, and the most important
functionality is described in the section <a href="#sec:files:str">Strings</a>.

<p>
The World Wide Web is full of information and scientific data that may
be useful to access from a program. The section <a href="#sec:files:webtxt">Reading data from web pages</a>
tells you how to read web pages from a program and interpret the
contents using string operations.

<p>
Working with data often involves spreadsheets. Python programs not
only need to extract data from spreadsheet files, but it can be
advantageous and convenient to actually to the data processing in a
Python program rather than in a spreadsheet program like Microsoft
Excel or LibreOffice.  The section <a href="#sec:files:csv">Reading and writing spreadsheet files</a> goes through relevant
techniques for reading and writing files in the common CSV format for
spreadsheets.

<p>
The present chapter builds on fundamental programming concepts such as
loops, lists, arrays, <code>if</code> tests, command-line arguments, and curve
plotting.  The folder <a href="http://tinyurl.com/pwyasaa/files" target="_self"><tt>src/files</tt></a> contains all
the relevant program example files and associated data files.

<p>


</div> <!-- end jumbotron -->

<h1 id="sec:files:dicts">Dictionaries<a name="sec:files:dicts"></a></h1>

So far in the document we have stored information in various types
of objects, such as numbers, strings, list, and arrays.
A <em>dictionary</em> is a very flexible object for
storing various kind of information, and in particular
when reading files. It is therefore
time to introduce the dictionary type.

<p>
A list is a collection of objects indexed by an integer going from
0 to the number of elements minus one.  Instead of looking up an element
through an integer index, it can be more handy to use a text.
Roughly speaking, a list where the index can be a text is called
a {dictionary} in Python. Other computer languages use other
names for the same thing: HashMap, hash, associative array, or
map.

<h2 id="___sec1">Making dictionaries <a name="___sec1"></a></h2>

Suppose we need to store
the temperatures from three cities: Oslo, London,
and Paris. For this purpose we can use a list,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">temps <span style="color: #666666">=</span> [<span style="color: #666666">13</span>, <span style="color: #666666">15.4</span>, <span style="color: #666666">17.5</span>]
</pre></div>
<p>
but then we need to remember the sequence of cities, e.g., that index 0
corresponds to Oslo, index 1 to London, and index 2 to Paris.
That is, the London temperature is obtained as <code>temps[1]</code>.
A dictionary with the city name as index is more convenient, because
this allows us to write <code>temps['London']</code> to look up the temperature
in London. Such a dictionary is created by one of the following two statements

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">temps <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;Oslo&#39;</span>: <span style="color: #666666">13</span>, <span style="color: #BA2121">&#39;London&#39;</span>: <span style="color: #666666">15.4</span>, <span style="color: #BA2121">&#39;Paris&#39;</span>: <span style="color: #666666">17.5</span>}
<span style="color: #408080; font-style: italic"># or</span>
temps <span style="color: #666666">=</span> <span style="color: #008000">dict</span>(Oslo<span style="color: #666666">=13</span>, London<span style="color: #666666">=15.4</span>, Paris<span style="color: #666666">=17.5</span>)
</pre></div>
<p>
Additional text-value pairs can be added when desired. We can, for instance,
write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">temps[<span style="color: #BA2121">&#39;Madrid&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">26.0</span>
</pre></div>
<p>
The <code>temps</code> dictionary has now four text-value pairs, and
a <code>print temps</code> yields

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{&#39;Oslo&#39;: 13, &#39;London&#39;: 15.4, &#39;Paris&#39;: 17.5, &#39;Madrid&#39;: 26.0}
</pre></div>
</blockquote><h2 id="___sec2">Dictionary operations <a name="___sec2"></a></h2>

The string &quot;indices&quot; in a dictionary are called <em>keys</em>.
To loop over the keys in a dictionary <code>d</code>, one writes
<code>for key in d:</code> and works with <code>key</code> and the
corresponding value <code>d[key]</code>
inside the loop. We may apply this technique to write out the
temperatures in the <code>temps</code> dictionary from the previous paragraph:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> city <span style="color: #AA22FF; font-weight: bold">in</span> temps:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;The temperature in </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (city, temps[city])
<span style="color: #666666">...</span>
The temperature <span style="color: #AA22FF; font-weight: bold">in</span> Paris <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #666666">17.5</span>
The temperature <span style="color: #AA22FF; font-weight: bold">in</span> Oslo <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #666666">13</span>
The temperature <span style="color: #AA22FF; font-weight: bold">in</span> London <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #666666">15.4</span>
The temperature <span style="color: #AA22FF; font-weight: bold">in</span> Madrid <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #666666">26</span>
</pre></div>
<p>
We can check if a key is present in a dictionary by the syntax
<code>if key in d</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Berlin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> temps:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Berlin:&#39;</span>, temps[<span style="color: #BA2121">&#39;Berlin&#39;</span>]
<span style="color: #666666">...</span> <span style="color: #008000; font-weight: bold">else</span>:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;No temperature data for Berlin&#39;</span>
<span style="color: #666666">...</span>
No temperature data <span style="color: #008000; font-weight: bold">for</span> Berlin
</pre></div>
<p>
Writing <code>key in d</code> yields a standard boolean expression, e.g.,

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;Oslo&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> temps
<span style="color: #008000">True</span>
</pre></div>
<p>
The keys and values can be extracted as lists from a dictionary:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> temps<span style="color: #666666">.</span>keys()
[<span style="color: #BA2121">&#39;Paris&#39;</span>, <span style="color: #BA2121">&#39;Oslo&#39;</span>, <span style="color: #BA2121">&#39;London&#39;</span>, <span style="color: #BA2121">&#39;Madrid&#39;</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> temps<span style="color: #666666">.</span>values()
[<span style="color: #666666">17.5</span>, <span style="color: #666666">13</span>, <span style="color: #666666">15.4</span>, <span style="color: #666666">26.0</span>]
</pre></div>
<p>
An important feature of the <code>keys</code> method in dictionaries
is that the order of the returned list of
keys is unpredictable. If you need to traverse the keys in a certain
order, you can sort the keys. A loop over the keys in the
<code>temps</code> dictionary in alphabetic order is written as

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> city <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(temps):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> city
<span style="color: #666666">...</span>
London
Madrid
Oslo
Paris
</pre></div>
<p>
Python also has a special dictionary type <code>OrderedDict</code>
where the key-value pairs has a specific order, see
the section <a href="#sec:files:dict:default:order">Dictionaries with default values and ordering</a>.

<p>
A key-value pair can be removed by <code>del d[key]</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">del</span> temps[<span style="color: #BA2121">&#39;Oslo&#39;</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> temps
{<span style="color: #BA2121">&#39;Paris&#39;</span>: <span style="color: #666666">17.5</span>, <span style="color: #BA2121">&#39;London&#39;</span>: <span style="color: #666666">15.4</span>, <span style="color: #BA2121">&#39;Madrid&#39;</span>: <span style="color: #666666">26.0</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">len</span>(temps)  <span style="color: #408080; font-style: italic"># no of key-value pairs in dictionary</span>
<span style="color: #666666">3</span>
</pre></div>
<p>
Sometimes we need to take a copy of a dictionary:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> temps_copy <span style="color: #666666">=</span> temps<span style="color: #666666">.</span>copy()
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">del</span> temps_copy[<span style="color: #BA2121">&#39;Paris&#39;</span>]   <span style="color: #408080; font-style: italic"># this does not affect temps</span>
<span style="color: #666666">&gt;&gt;&gt;</span> temps_copy
{<span style="color: #BA2121">&#39;London&#39;</span>: <span style="color: #666666">15.4</span>, <span style="color: #BA2121">&#39;Madrid&#39;</span>: <span style="color: #666666">26.0</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> temps
{<span style="color: #BA2121">&#39;Paris&#39;</span>: <span style="color: #666666">17.5</span>, <span style="color: #BA2121">&#39;London&#39;</span>: <span style="color: #666666">15.4</span>, <span style="color: #BA2121">&#39;Madrid&#39;</span>: <span style="color: #666666">26.0</span>}
</pre></div>
<p>
Note that if two variables refer to the same dictionary and we change
the contents of the dictionary through either of the variables,
the change will be seen in both variables:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> t1 <span style="color: #666666">=</span> temps
<span style="color: #666666">&gt;&gt;&gt;</span> t1[<span style="color: #BA2121">&#39;Stockholm&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">10.0</span>    <span style="color: #408080; font-style: italic"># change t1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> temps                     <span style="color: #408080; font-style: italic"># temps is also changed</span>
{<span style="color: #BA2121">&#39;Stockholm&#39;</span>: <span style="color: #666666">10.0</span>, <span style="color: #BA2121">&#39;Paris&#39;</span>: <span style="color: #666666">17.5</span>, <span style="color: #BA2121">&#39;London&#39;</span>: <span style="color: #666666">15.4</span>, <span style="color: #BA2121">&#39;Madrid&#39;</span>: <span style="color: #666666">26.0</span>}
</pre></div>
<p>
To avoid that <code>temps</code> is affected by adding a new key-value pair
to <code>t1</code>, <code>t1</code> must be a copy of <code>temps</code>.

<h3 id="___sec3">Remark <a name="___sec3"></a></h3>

In Python version 2.x, <code>temps.keys()</code> returns a list object while
in Python version 3.x, <code>temps.keys()</code> only enables iterating over
the keys. To write code that works with both versions one can
use <code>list(temps.keys())</code> in the cases where a list is really
needed and just <code>temps.keys()</code> in a <code>for</code> loop over the keys.

<h2 id="sec:files:poly">Example: Polynomials as dictionaries<a name="sec:files:poly"></a></h2>
<a name="sec:files:mutable"></a>

<p>
Python objects that cannot change their contents
are known as <em>immutable</em> data types
and consist of <code>int</code>, <code>float</code>, <code>complex</code>,
<code>str</code>, and <code>tuple</code>. Lists and dictionaries
can change their contents and are called
<em>mutable</em> objects.

<p>
The keys in a dictionary are not restricted to be strings. In fact,
any immutable Python object can be used as key.
For example, if you want a list as key, it cannot be used since lists
can change their contents are hence mutable objects, but a tuple
will do, since it is immutable.

<p>
A common type of key in dictionaries is integers.
Next we shall explain how dictionaries with integers as key provide
a handy way of representing polynomials.
Consider the polynomial

$$
\begin{equation*} p(x)=-1 + x^2 + 3x^7\tp \end{equation*}
$$

The data associated with this polynomial can be viewed as
a set of power-coefficient pairs, in this case the coefficient \( -1 \)
belongs to power 0, the coefficient 1 belongs to power 2, and the
coefficient 3 belongs to power 7. A dictionary can be used to map a
power to a coefficient:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #666666">-1</span>, <span style="color: #666666">2</span>: <span style="color: #666666">1</span>, <span style="color: #666666">7</span>: <span style="color: #666666">3</span>}
</pre></div>
<p>
A list can, of course, also be used, but in this case we must
fill in all the zero coefficients too, since the index must match the power:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> [<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>]
</pre></div>
<p>
The advantage with a dictionary is that we need to store only the
non-zero coefficients. For the polynomial \( 1+x^{100} \) the dictionary
holds two elements while the list holds 101 elements (see <a href="#sec:files:ex16">Exercise 10: Compare data structures for polynomials</a>).

<p>
The following function can be used to evaluate a polynomial represented
as a dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">poly1</span>(data, x):
    <span style="color: #008000">sum</span> <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">for</span> power <span style="color: #AA22FF; font-weight: bold">in</span> data:
        <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> data[power]<span style="color: #666666">*</span>x<span style="color: #666666">**</span>power
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">sum</span>
</pre></div>
<p>
The <code>data</code> argument must be a dictionary where <code>data[power]</code>
holds the coefficient associated with the term <code>x**power</code>.
A more compact implementation can make use of Python's <code>sum</code>
function to sum the elements of a list:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">poly1_lc</span>(data, x):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">sum</span>([data[p]<span style="color: #666666">*</span>x<span style="color: #666666">**</span>p <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> data])
</pre></div>
<p>
That is, we first make a list of the terms in the polynomial using a
list comprehension, and then we feed this list to the <code>sum</code>
function (we can in fact drop the brackets and storing the list -
<code>sum</code> can directly add the <code>data[p]*x**p</code> terms).
Note that the name <code>sum</code> is different in the two
implementations: in the first, <code>sum</code> is a <code>float</code> object, and in the
second, <code>sum</code> is a function. When we set <code>sum=0.0</code> in the first
implementation, we bind the name <code>sum</code> to a new <code>float</code> object, and
the built-in Python function associated with the name <code>sum</code> is then no
longer accessible inside the <code>poly1</code> function (actually, this is not
strictly correct, because <code>sum</code> is a local variable while the
summation function is associated with a global name <code>sum</code>, which can
always be reached through <code>globals()['sum']</code>).  Outside the function,
nevertheless, <code>sum</code> will be the summation function (unless we have
bound the global name <code>sum</code> to another object somewhere else in the
main program.

<p>
With a list instead of dictionary for representing
the polynomial, a slightly different evaluation function is needed:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">poly2</span>(data, x):
    <span style="color: #008000">sum</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> power <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(data)):
        <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> data[power]<span style="color: #666666">*</span>x<span style="color: #666666">**</span>power
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">sum</span>
</pre></div>
<p>
If there are many zeros in the <code>data</code> list, <code>poly2</code> must
perform all the multiplications with the zeros, while <code>poly1</code>
computes with the non-zero coefficients only and is hence more
efficient.

<p>
Another major advantage of using a dictionary to represent a polynomial rather
than a list is that negative powers are easily allowed, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> {<span style="color: #666666">-3</span>: <span style="color: #666666">0.5</span>, <span style="color: #666666">4</span>: <span style="color: #666666">2</span>}
</pre></div>
<p>
can represent \( \frac{1}{2}x^{-3} + 2x^4 \). With a list representation,
negative powers require much more book-keeping. We may, for example,
set

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p <span style="color: #666666">=</span> [<span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>]
</pre></div>
<p>
and remember that <code>p[i]</code> is the coefficient associated with the
power <code>i-3</code>. In particular, the <code>poly2</code> function will no longer
work for such lists, while the <code>poly1</code> function
works also for dictionaries with negative keys (powers).

<p>
There is a dictionary counterpart to list comprehensions, called
<em>dictionary comprehensions</em>, for quickly generating parameterized
key-value pairs
with a <code>for</code> loop. Such a construction is convenient to generate
the coefficients in a polynomial:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> factorial
d <span style="color: #666666">=</span> {k: (<span style="color: #666666">-1</span>)<span style="color: #666666">**</span>k<span style="color: #666666">/</span>factorial(k) <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n<span style="color: #666666">+1</span>)}
</pre></div>
<p>
The <code>d</code> dictionary now contains the power-coefficient pairs of the
Taylor polynomial of degree <code>n</code> for \( e^{-x} \).

<p>
You are now encouraged to solve <a href="#sec:files:ex3">Exercise 11: Compute the derivative of a polynomial</a>
to become more familiar with the concept
of dictionaries.

<h2 id="sec:files:dict:default:order">Dictionaries with default values and ordering<a name="sec:files:dict:default:order"></a></h2>

<h3 id="___sec6">Dictionaries with default values <a name="___sec6"></a></h3>

Looking up keys that are not present in the dictionary requires
special treatment. Consider a polynomial dictionary of the type
introduced in the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>. Say we have
\( 2x^{-3} -1.5x^{-1} -2x^2 \) represented by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p1 <span style="color: #666666">=</span> {<span style="color: #666666">-3</span>: <span style="color: #666666">2</span>, <span style="color: #666666">-1</span>: <span style="color: #666666">-1.5</span>, <span style="color: #666666">2</span>: <span style="color: #666666">-2</span>}
</pre></div>
<p>
If the code tries to look up <code>p1[1]</code>,
this operation results in a <code>KeyError</code> since <code>1</code> is
not a registered key in <code>p1</code>. We therefore need to do either

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> key <span style="color: #AA22FF; font-weight: bold">in</span> p1:
   value <span style="color: #666666">=</span> p1[key]
</pre></div>
<p>
or use

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">value <span style="color: #666666">=</span> p1<span style="color: #666666">.</span>get(key, <span style="color: #666666">0.0</span>)
</pre></div>
<p>
where <code>p1.get</code> returns <code>p1[key]</code> if <code>key in p1</code>
and the default value <code>0.0</code> if not.
A third possibility is to work with a dictionary with a
default value:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">collections</span> <span style="color: #008000; font-weight: bold">import</span> defaultdict

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">polynomial_coeff_default</span>():
    <span style="color: #408080; font-style: italic"># default value for polynomial dictionary</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>

p2 <span style="color: #666666">=</span> defaultdict(polynomial_coeff_default)
p2<span style="color: #666666">.</span>update(p1)
</pre></div>
<p>
The <code>p2</code> can be indexed by any key, and for unregistered keys
the <code>polynomial_coeff_default</code> function is called to provide
a value. This must be a function without arguments. Usually,
a separate function is never made, but either a type is inserted
or a lambda function. The example above is equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">p2 <span style="color: #666666">=</span> defaultdict(<span style="color: #008000; font-weight: bold">lambda</span>: <span style="color: #666666">0.0</span>)
p2 <span style="color: #666666">=</span> defaultdict(<span style="color: #008000">float</span>)
</pre></div>
<p>
In the latter case <code>float()</code> is called for each unknown key,
and <code>float()</code> returns a <code>float</code> object with zero value.
Now we can look up <code>p2[1]</code> and get the default value 0.
It must be remarked that this key is then a part of the dictionary:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> p2 <span style="color: #666666">=</span> defaultdict(<span style="color: #008000; font-weight: bold">lambda</span>: <span style="color: #666666">0.0</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> p2<span style="color: #666666">.</span>update({<span style="color: #666666">2</span>: <span style="color: #666666">8</span>})  <span style="color: #408080; font-style: italic"># only one key</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p2[<span style="color: #666666">1</span>]
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p2[<span style="color: #666666">0</span>]
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p2[<span style="color: #666666">-2</span>]
<span style="color: #666666">0.0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> p2
{<span style="color: #666666">0</span>: <span style="color: #666666">0.0</span>, <span style="color: #666666">1</span>: <span style="color: #666666">0.0</span>, <span style="color: #666666">2</span>: <span style="color: #666666">8</span>, <span style="color: #666666">-2</span>: <span style="color: #666666">0.0</span>}
</pre></div>

<h3 id="___sec7">Ordered dictionaries <a name="___sec7"></a></h3>

The elements of a dictionary have an undefined order. For example,

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> p1 <span style="color: #666666">=</span> {<span style="color: #666666">-3</span>: <span style="color: #666666">2</span>, <span style="color: #666666">-1</span>: <span style="color: #666666">-1.5</span>, <span style="color: #666666">2</span>: <span style="color: #666666">-2</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> p1
{<span style="color: #666666">2</span>: <span style="color: #666666">-2</span>, <span style="color: #666666">-3</span>: <span style="color: #666666">2</span>, <span style="color: #666666">-1</span>: <span style="color: #666666">-1.5</span>}
</pre></div>
<p>
One can control the order my sorting the keys, either by the
default sorting (alphabetically for string keys, ascending order
for number keys):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(p1):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> key, p1[key]
<span style="color: #666666">...</span>
<span style="color: #666666">-3</span> <span style="color: #666666">2</span>
<span style="color: #666666">-1</span> <span style="color: #666666">-1.5</span>
<span style="color: #666666">2</span> <span style="color: #666666">-2</span>
</pre></div>
<p>
The <code>sorted</code> function also accept an optional argument where
the user can supply a function that sorts two keys
(see ref{sec:basic:ex28}).

<p>
However, Python features a dictionary type that preserves the order
of the keys as they were registered:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">collections</span> <span style="color: #008000; font-weight: bold">import</span> OrderedDict
<span style="color: #666666">&gt;&gt;&gt;</span> p2 <span style="color: #666666">=</span> OrderedDict({<span style="color: #666666">-3</span>: <span style="color: #666666">2</span>, <span style="color: #666666">-1</span>: <span style="color: #666666">-1.5</span>, <span style="color: #666666">2</span>: <span style="color: #666666">-2</span>})
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> p2
OrderedDict([(<span style="color: #666666">2</span>, <span style="color: #666666">-2</span>), (<span style="color: #666666">-3</span>, <span style="color: #666666">2</span>), (<span style="color: #666666">-1</span>, <span style="color: #666666">-1.5</span>)])
<span style="color: #666666">&gt;&gt;&gt;</span> p2[<span style="color: #666666">-5</span>] <span style="color: #666666">=</span> <span style="color: #666666">6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> p2:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> key, p2[key]
<span style="color: #666666">...</span>
<span style="color: #666666">2</span> <span style="color: #666666">-2</span>
<span style="color: #666666">-3</span> <span style="color: #666666">2</span>
<span style="color: #666666">-1</span> <span style="color: #666666">-1.5</span>
<span style="color: #666666">-5</span> <span style="color: #666666">6</span>
</pre></div>
<p>
Here is an example with dates as keys where the order is important.

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> data <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;Jan 2&#39;</span>: <span style="color: #666666">33</span>, <span style="color: #BA2121">&#39;Jan 16&#39;</span>: <span style="color: #666666">0.1</span>, <span style="color: #BA2121">&#39;Feb 2&#39;</span>: <span style="color: #666666">2</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> date <span style="color: #AA22FF; font-weight: bold">in</span> data:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> date, data[date]
<span style="color: #666666">...</span>
Feb <span style="color: #666666">2</span> <span style="color: #666666">2</span>
Jan <span style="color: #666666">2</span> <span style="color: #666666">33</span>
Jan <span style="color: #666666">16</span> <span style="color: #666666">0.1</span>
</pre></div>
<p>
The order of the keys in the loop is not the right registered order,
but this is easily achieved by <code>OrderedDict</code>

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> data <span style="color: #666666">=</span> OrderedDict()
<span style="color: #666666">&gt;&gt;&gt;</span> data[<span style="color: #BA2121">&#39;Jan 2&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">33</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data[<span style="color: #BA2121">&#39;Jan 16&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data[<span style="color: #BA2121">&#39;Feb 2&#39;</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> date <span style="color: #AA22FF; font-weight: bold">in</span> data:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> date, data[date]
<span style="color: #666666">...</span>
Jan2 <span style="color: #666666">33</span>
Jan <span style="color: #666666">16</span> <span style="color: #666666">0.1</span>
Feb <span style="color: #666666">2</span> <span style="color: #666666">2</span>
</pre></div>
<p>
A comment on alternative solutions
should be made here. Trying to sort the <code>data</code> dictionary
when it is an ordinary <code>dict</code> object does not help, as by
default the sorting will be alphabetically, resulting in
the sequence <code>'Feb 2'</code>, <code>'Jan 16'</code>, and <code>'Jan 2'</code>.
What does help, however, is to use Python's <code>datetime</code> objects
as keys reflecting dates, since these objects will be correctly
sorted. A <code>datetime</code> object can be created from
a string like <code>'Jan 2, 2017'</code> using a special syntax
(see the module documentation). The relevant code is

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">datetime</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data <span style="color: #666666">=</span> {}
<span style="color: #666666">&gt;&gt;&gt;</span> d <span style="color: #666666">=</span> datetime<span style="color: #666666">.</span>datetime<span style="color: #666666">.</span>strptime  <span style="color: #408080; font-style: italic"># short form</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data[d(<span style="color: #BA2121">&#39;Jan 2, 2017&#39;</span>, <span style="color: #BA2121">&#39;%b </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, %Y&#39;</span>)] <span style="color: #666666">=</span> <span style="color: #666666">33</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data[d(<span style="color: #BA2121">&#39;Jan 16, 2017&#39;</span>, <span style="color: #BA2121">&#39;%b </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, %Y&#39;</span>)] <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> data[d(<span style="color: #BA2121">&#39;Feb 2, 2017&#39;</span>, <span style="color: #BA2121">&#39;%b </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, %Y&#39;</span>)] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
</pre></div>
<p>
Printing out in sorted order gives the right sequence of dates:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> date <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(data):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> date, data[date]
<span style="color: #666666">...</span>
<span style="color: #666666">2017-01-02</span> <span style="color: #666666">00</span>:<span style="color: #666666">00</span>:<span style="color: #666666">00</span> <span style="color: #666666">33</span>
<span style="color: #666666">2017-01-16</span> <span style="color: #666666">00</span>:<span style="color: #666666">00</span>:<span style="color: #666666">00</span> <span style="color: #666666">0.1</span>
<span style="color: #666666">2017-02-02</span> <span style="color: #666666">00</span>:<span style="color: #666666">00</span>:<span style="color: #666666">00</span> <span style="color: #666666">2</span>
</pre></div>
<p>
The time is automatically part of a <code>datetime</code> object and set to
<code>00:00:00</code> when not specified.

<p>
While <code>OrderedDict</code> provides a simpler and shorter solution
to keeping keys (here dates) in the right order in a dictionary,
using <code>datetime</code> objects for dates has many advantages: dates can be
formatted and written out in various ways, counting days between two dates is
easy (see the section ref{sec:diffeq:irates}),
calculating the corresponding week number and name of the weekday
is supported, to mention some functionality.

<h2 id="sec:files:dict:density">Example: File data in dictionaries<a name="sec:files:dict:density"></a></h2>

<h3 id="___sec9">Problem <a name="___sec9"></a></h3>

The file <code>files/densities.dat</code> contains a table of densities of
various substances measured in \( \hbox{g}/\hbox{cm}^3 \):

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">air         0.0012
gasoline    0.67
ice         0.9
pure water  1.0
seawater    1.025
human body  1.03
limestone   2.6
granite     2.7
iron        7.8
silver      10.5
mercury     13.6
gold        18.9
platinium   21.4
Earth mean  5.52
Earth core  13
Moon        3.3
Sun mean    1.4
Sun core    160
proton      2.3E+14
</pre></div>
<p>
In a program we want to access these density data.
A dictionary
with the name of the substance as key and the corresponding density
as value seems well suited for storing the data.

<h3 id="___sec10">Solution <a name="___sec10"></a></h3>

We can read the <code>densities.dat</code> file line by line, split each line
into words, use a float conversion of the last word as density value,
and the remaining one or two words as key in the dictionary.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_densities</span>(filename):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    densities <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        density <span style="color: #666666">=</span> <span style="color: #008000">float</span>(words[<span style="color: #666666">-1</span>])

        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(words[:<span style="color: #666666">-1</span>]) <span style="color: #666666">==</span> <span style="color: #666666">2</span>:
            substance <span style="color: #666666">=</span> words[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; &#39;</span> <span style="color: #666666">+</span> words[<span style="color: #666666">1</span>]
        <span style="color: #008000; font-weight: bold">else</span>:
            substance <span style="color: #666666">=</span> words[<span style="color: #666666">0</span>]

        densities[substance] <span style="color: #666666">=</span> density
    infile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">return</span> densities

densities <span style="color: #666666">=</span> read_densities(<span style="color: #BA2121">&#39;densities.dat&#39;</span>)
</pre></div>
<p>
This code is found in the file
<a href="http://tinyurl.com/pwyasaa/files/density.py" target="_self"><tt>density.py</tt></a>. With
string operations
from the section <a href="#sec:files:stringop">Common operations on strings</a> we can avoid the special treatment
of one or two words in the name of the substance and achieve simpler and
more general code, see <a href="#sec:files:ex17">Exercise 3: Use string operations to improve a program</a>.

<h2 id="sec:files:dictdict">Example: File data in nested dictionaries<a name="sec:files:dictdict"></a></h2>

<!-- keep this example, it has a lot of nice details - then add a section -->
<!-- on Microsoft_table_monthly.csv -->

<h3 id="___sec12">Problem <a name="___sec12"></a></h3>

We are given a data file with measurements of some properties
with given names (here <code>A</code>, <code>B</code>, <code>C</code> ...).
Each property is measured a given number of times.
The data are organized as a table where the rows contain
the measurements and the columns represent the measured properties:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">       A        B       C      D
1     11.7    0.035    2017    99.1
2      9.2    0.037    2019   101.2
3     12.2     no       no    105.2
4     10.1    0.031     no    102.1
5      9.1    0.033    2009   103.3
6      8.7    0.036    2015   101.9
</pre></div>
<p>
The word <code>no</code> stands for no data, i.e., we lack a measurement.
We want to read this table into a dictionary <code>data</code> so that
we can look up measurement no. <code>i</code> of (say) property <code>C</code>
as <code>data['C'][i]</code>.
For each property <code>p</code>, we want to compute the mean of all measurements
and store this as <code>data[p]['mean']</code>.

<h3 id="___sec13">Algorithm <a name="___sec13"></a></h3>

The algorithm for creating the <code>data</code> dictionary goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">examine the first line: split it into words <span style="color: #AA22FF; font-weight: bold">and</span>
initialize a dictionary <span style="color: #008000; font-weight: bold">with</span> the <span style="color: #008000">property</span> names
<span style="color: #008000; font-weight: bold">as</span> keys <span style="color: #AA22FF; font-weight: bold">and</span> empty dictionaries {} <span style="color: #008000; font-weight: bold">as</span> values

<span style="color: #008000; font-weight: bold">for</span> each of the remaining lines <span style="color: #AA22FF; font-weight: bold">in</span> the <span style="color: #008000">file</span>:
    split the line into words
    <span style="color: #008000; font-weight: bold">for</span> each word after the first:
        <span style="color: #008000; font-weight: bold">if</span> the word <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #BA2121">`no`</span>:
            transform the word to a real number <span style="color: #AA22FF; font-weight: bold">and</span> store
            the number <span style="color: #AA22FF; font-weight: bold">in</span> the relevant dictionary
</pre></div>
<p>
<!-- #eldif ALG == "list" -->

<ul>
 <li> examine the first line: split it into words and
   initialize a dictionary with the property names
   as keys and empty dictionaries {} as values</li>
 <li> for each of the remaining lines in the file</li>

<ul>
    <li> split the line into words</li>
    <li> for each word after the first</li>

<ul>
       <li> if the word is not <code>no</code>:</li>

<ul>
           <li> transform the word to a real number and store
             the number in the relevant dictionary</li>
</ul>

</ul>

</ul>

</ul>

<h3 id="___sec14">Implementation <a name="___sec14"></a></h3>

A new aspect needed in the solution is <em>nested dictionaries</em>, that is,
dictionaries of dictionaries. The latter topic is first explained, via an
example:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> d <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;key1&#39;</span>: {<span style="color: #BA2121">&#39;key1&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;key2&#39;</span>: <span style="color: #666666">3</span>}, <span style="color: #BA2121">&#39;key2&#39;</span>: <span style="color: #666666">7</span>}
</pre></div>
<p>
Observe here that the value of
<code>d['key1']</code> is a dictionary, which we can index with its
keys <code>key1</code> and <code>key2</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> d[<span style="color: #BA2121">&#39;key1&#39;</span>]            <span style="color: #408080; font-style: italic"># this is a dictionary</span>
{<span style="color: #BA2121">&#39;key2&#39;</span>: <span style="color: #666666">3</span>, <span style="color: #BA2121">&#39;key1&#39;</span>: <span style="color: #666666">2</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(d[<span style="color: #BA2121">&#39;key1&#39;</span>])      <span style="color: #408080; font-style: italic"># proof</span>
<span style="color: #666666">&lt;</span><span style="color: #008000">type</span> <span style="color: #BA2121">&#39;dict&#39;</span><span style="color: #666666">&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> d[<span style="color: #BA2121">&#39;key1&#39;</span>][<span style="color: #BA2121">&#39;key1&#39;</span>]    <span style="color: #408080; font-style: italic"># index a nested dictionary</span>
<span style="color: #666666">2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> d[<span style="color: #BA2121">&#39;key1&#39;</span>][<span style="color: #BA2121">&#39;key2&#39;</span>]
<span style="color: #666666">3</span>
</pre></div>
<p>
In other words, repeated indexing works for nested dictionaries as for
nested lists.
The repeated indexing does not apply to <code>d['key2']</code>
since that value is just an integer:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> d[<span style="color: #BA2121">&#39;key2&#39;</span>][<span style="color: #BA2121">&#39;key1&#39;</span>]
  <span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">TypeError</span>: unsubscriptable <span style="color: #008000">object</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(d[<span style="color: #BA2121">&#39;key2&#39;</span>])
<span style="color: #666666">&lt;</span><span style="color: #008000">type</span> <span style="color: #BA2121">&#39;int&#39;</span><span style="color: #666666">&gt;</span>
</pre></div>
<p>
<!-- is it not better to translate the algorithm step by step -->
<!-- instead of presenting the final solution? -->

<p>
When we have understood the concept of
nested dictionaries, we are in a position
to present a complete code that solves our problem
of loading the tabular data in the file <code>table.dat</code> into a nested
dictionary <code>data</code> and computing mean values.
First, we list the program, stored in the file
<a href="http://tinyurl.com/pwyasaa/files/table2dict.py" target="_self"><tt>table2dict.py</tt></a>,
and display the program's output. Thereafter, we dissect the code
in detail.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;table.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
lines <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readlines()
infile<span style="color: #666666">.</span>close()
data <span style="color: #666666">=</span> {}   <span style="color: #408080; font-style: italic">#  data[property][measurement_no] = propertyvalue</span>
first_line <span style="color: #666666">=</span> lines[<span style="color: #666666">0</span>]
properties <span style="color: #666666">=</span> first_line<span style="color: #666666">.</span>split()
<span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> properties:
    data[p] <span style="color: #666666">=</span> {}

<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines[<span style="color: #666666">1</span>:]:
    words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
    i <span style="color: #666666">=</span> <span style="color: #008000">int</span>(words[<span style="color: #666666">0</span>])       <span style="color: #408080; font-style: italic"># measurement number</span>
    values <span style="color: #666666">=</span> words[<span style="color: #666666">1</span>:]      <span style="color: #408080; font-style: italic"># values of properties</span>
    <span style="color: #008000; font-weight: bold">for</span> p, v <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(properties, values):
        <span style="color: #008000; font-weight: bold">if</span> v <span style="color: #666666">!=</span> <span style="color: #BA2121">&#39;no&#39;</span>:
            data[p][i] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(v)

<span style="color: #408080; font-style: italic"># Compute mean values</span>
<span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> data:
    values <span style="color: #666666">=</span> data[p]<span style="color: #666666">.</span>values()
    data[p][<span style="color: #BA2121">&#39;mean&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(values)<span style="color: #666666">/</span><span style="color: #008000">len</span>(values)

<span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(data):
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Mean value of property </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (p, data[p][<span style="color: #BA2121">&#39;mean&#39;</span>])
</pre></div>
<p>
The corresponding output from this program becomes

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Mean value of property A = 10.1667
Mean value of property B = 0.0344
Mean value of property C = 2015
Mean value of property D = 102.133
</pre></div>
</blockquote><p>
To view the nested <code>data</code> dictionary, we may insert

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.pprint2</span>; scitools<span style="color: #666666">.</span>pprint2<span style="color: #666666">.</span>pprint(data)
</pre></div>
<p>
which produces something like

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{&#39;A&#39;: {1: 11.7, 2: 9.2, 3: 12.2, 4: 10.1, 5: 9.1, 6: 8.7,
       &#39;mean&#39;: 10.1667},
 &#39;B&#39;: {1: 0.035, 2: 0.037, 4: 0.031, 5: 0.033, 6: 0.036,
       &#39;mean&#39;: 0.0344},
 &#39;C&#39;: {1: 2017, 2: 2019, 5: 2009, 6: 2015, &#39;mean&#39;: 2015},
 &#39;D&#39;: {1: 99.1,
       2: 101.2,
       3: 105.2,
       4: 102.1,
       5: 103.3,
       6: 101.9,
       &#39;mean&#39;: 102.133}}
</pre></div>
</blockquote><h3 id="___sec15">Dissection <a name="___sec15"></a></h3>

To understand a computer program, you need to
understand what the result of every statement is.
Let us work through the code, almost line by line, and see what it does.

<p>
First, we load all the lines of the file into a list of strings
called <code>lines</code>.
The <code>first_line</code> variable refers to the string

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121">&#39;       A        B       C      D&#39;</span>
</pre></div>
<p>
We split this line into a list of words, called <code>properties</code>,
which then contains

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[<span style="color: #BA2121">&#39;A&#39;</span>, <span style="color: #BA2121">&#39;B&#39;</span>, <span style="color: #BA2121">&#39;C&#39;</span>, <span style="color: #BA2121">&#39;D&#39;</span>]
</pre></div>
<p>
With each of these property names we associate a dictionary with
the measurement number as key and the property value as value,
but first we must create these &quot;inner&quot; dictionaries as empty
before we can add the measurements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> properties:
    data[p] <span style="color: #666666">=</span> {}
</pre></div>
<p>
The first pass in the <code>for</code> loop picks out the string

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121">&#39;1     11.7    0.035    2017    99.1&#39;</span>
</pre></div>
<p>
as the <code>line</code> variable. We split this line into words,
the first word (<code>words[0]</code>) is the measurement number, while the
rest <code>words[1:]</code> is a list of property values, here named <code>values</code>.
To pair up the right properties and values, we loop over
the <code>properties</code> and <code>values</code> lists simultaneously:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">for</span> p, v <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(properties, values):
        <span style="color: #008000; font-weight: bold">if</span> v <span style="color: #666666">!=</span> <span style="color: #BA2121">&#39;no&#39;</span>:
            data[p][i] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(v)
</pre></div>
<p>
Recall that some values may be missing and we drop to record
that value (we could, alternatively, set the value to <code>None</code>).
Because the <code>values</code> list contains strings (words) read from
the file, we need to explicitly transform each string to a <code>float</code> number
before we can compute with the values.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Illustration of the nested dictionary created in the <code>table2dict.py</code> program. <a name="sec:files:fig2"></a> </p></center>
<p><img src="fig-files/lumpy_table2dict2.png" align="bottom" width=400></p>
</center>

<p>
After the <code>for line in lines[1:]</code> loop, we have a dictionary <code>data</code> of
dictionaries where all the property values are stored for each
measurement number and property name.  Figure <a href="#sec:files:fig2">1</a>
shows a graphical representation of the <code>data</code> dictionary.

<p>
It remains to compute the average values. For each property name <code>p</code>,
i.e., key in the <code>data</code> dictionary, we can extract the recorded values
as the list <code>data[p].values()</code> and simply send this list to Python's
<code>sum</code> function and divide by the number of measured values for this
property, i.e., the length of the list:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> data:
    values <span style="color: #666666">=</span> data[p]<span style="color: #666666">.</span>values()
    data[p][<span style="color: #BA2121">&#39;mean&#39;</span>] <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(values)<span style="color: #666666">/</span><span style="color: #008000">len</span>(values)
</pre></div>
<p>
Alternatively, we can write an explicit loop to compute the average:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> data:
    sum_values <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> value <span style="color: #AA22FF; font-weight: bold">in</span> data[p]:
        sum_values <span style="color: #666666">+=</span> value
    data[p][<span style="color: #BA2121">&#39;mean&#39;</span>] <span style="color: #666666">=</span> sum_values<span style="color: #666666">/</span><span style="color: #008000">len</span>(data[p])
</pre></div>
<p>
When we want to look up a measurement no. <code>n</code> of property <code>B</code>, we
must recall that this particular measurement may be missing so we
must do a test if <code>n</code> is key in the dictionary <code>data[p]</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> n <span style="color: #AA22FF; font-weight: bold">in</span> data[<span style="color: #BA2121">&#39;B&#39;</span>]:
    value <span style="color: #666666">=</span> data[<span style="color: #BA2121">&#39;B&#39;</span>][n]

<span style="color: #408080; font-style: italic"># alternative:</span>
value <span style="color: #666666">=</span> data[<span style="color: #BA2121">&#39;B&#39;</span>][n] <span style="color: #008000; font-weight: bold">if</span> n <span style="color: #AA22FF; font-weight: bold">in</span> data[<span style="color: #BA2121">&#39;B&#39;</span>] <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">None</span>
</pre></div>

<h2 id="sec:files:stockprices">Example: Reading and plotting data recorded at specific dates<a name="sec:files:stockprices"></a></h2>

<h3 id="___sec17">Problem <a name="___sec17"></a></h3>

We want to compare the evolution of the stock prices
of some giant companies in the computer industry: Microsoft, Apple,
and Google. Relevant data files for stock prices can be downloaded from
<a href="http://finance.yahoo.com" target="_self"><tt>http://finance.yahoo.com</tt></a>.
Fill in the company's name and click on <em>Search Finance</em>
in the top bar of this page and choose <em>Historical Prices</em> in the left
pane.
On the resulting web page one can specify start and end dates
for the historical prices of the stock. The default values were
used in this example. Ticking off <em>Monthly</em> values
and clicking <em>Get Prices</em> result in a table of stock prices for
each month since the stock was introduced.
The table can be downloaded as a spreadsheet file in CSV format,
typically looking like

<p>

<!-- code=text (!bc dsni) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Date,Open,High,Low,Close,Volume,Adj Close
2014-02-03,502.61,551.19,499.30,545.99,12244400,545.99
2014-01-02,555.68,560.20,493.55,500.60,15698500,497.62
2013-12-02,558.00,575.14,538.80,561.02,12382100,557.68
2013-11-01,524.02,558.33,512.38,556.07,9898700,552.76
2013-10-01,478.45,539.25,478.28,522.70,12598400,516.57
...
1984-11-01,25.00,26.50,21.87,24.75,5935500,2.71
1984-10-01,25.00,27.37,22.50,24.87,5654600,2.73
1984-09-07,26.50,29.00,24.62,25.12,5328800,2.76
</pre></div>
<p>
The file format is simple: columns are separated by comma, the first
line contains column headings, and the data lines have the date in the
first column and various measures of stock prices in the next
columns. Reading about the meaning of the various data on the Yahoo!
web pages reveals that our interest concerns the final column (as
these prices are adjusted for splits and dividends). Three relevant
data files can be found in the folder <a href="http://tinyurl.com/pwyasaa/files" target="_self"><tt>src/files</tt></a> with the names <code>stockprices_X.csv</code>, where <code>X</code> is
<code>Microsoft</code>, <code>Sun</code>, or <code>Google</code>.

<p>
The task is visually illustrate the historical, relative stock market
value of these companies. For this purpose
it is natural to scale the prices of a company's stock to start at
a unit value when the most recent company entered the market.
Since the date of entry varies, the oldest data point can be skipped
such that all data points correspond to the first trade day every
month.

<h3 id="___sec18">Solution <a name="___sec18"></a></h3>

There are two major parts of this problem: reading the file and
plotting the data. The reading part is quite straightforward, while
the plotting part needs some special considerations since the
\( x \) values in the plot are dates and not real numbers.
In the forthcoming text we solve the individual subproblems one by one,
showing the relevant Python snippets. The complete program is found in the
file <a href="http://tinyurl.com/pwyasaa/files/stockprices.py" target="_self"><tt>stockprices.py</tt></a>.

<p>
We start with the reading part. Since the reading will be repeated for
several companies, we create a function for extracting the relevant
data for a specific company. These data cover the dates in column 1
and the stock prices in the last column. Since we want to plot
prices versus dates, it will be convenient to turn the dates into
<code>date</code> objects. In more detail the algorithms has the following
points:

<ol>
<li> open the file</li>
<li> create two empty lists, dates and prices, for collecting the data</li>
<li> read the first line (of no interest)</li>
<li> for each line in the rest of the file:</li>

<ol>
  <li> split the line wrt. comma into words</li>
  <li> append the first word to the dates list</li>
  <li> append the last word to the prices list</li>
</ol>

<li> reverse the lists (oldest date first)</li>
<li> convert date strings to datetime objects</li>
<li> convert prices list to float array for computations</li>
<li> return dates and prices, except for the first (oldest) data point</li>
</ol>

There are a couple of additional points to consider. First,
the words on a line are strings, and at least the prices (last word)
should be converted to a float. Second, the recipe for converting
dates like '2008-02-04' to <code>date</code> (or <code>datetime</code>) objects goes as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">datetime</span> <span style="color: #008000; font-weight: bold">import</span> datetime
datefmt <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;%Y-%m-</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span>  <span style="color: #408080; font-style: italic"># date format YYYY-MM-DD used in datetime</span>
strdate <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;2008-02-04&#39;</span>
datetime_object <span style="color: #666666">=</span> datetime<span style="color: #666666">.</span>strptime(strdate, datefmt)
date_object <span style="color: #666666">=</span> datetime_object<span style="color: #666666">.</span>date()
</pre></div>
<p>
The nice thing with <code>date</code> and <code>datetime</code> object is that we
can computed with them and in particular used them in
plotting with Matplotlib.

<p>
We can now translate the algorithm to Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">datetime</span> <span style="color: #008000; font-weight: bold">import</span> datetime

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_file</span>(filename):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    infile<span style="color: #666666">.</span>readline()  <span style="color: #408080; font-style: italic"># read column headings</span>
    dates <span style="color: #666666">=</span> [];  prices <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;,&#39;</span>)
        dates<span style="color: #666666">.</span>append(words[<span style="color: #666666">0</span>])
        prices<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(words[<span style="color: #666666">-1</span>]))
    infile<span style="color: #666666">.</span>close()
    dates<span style="color: #666666">.</span>reverse()
    prices<span style="color: #666666">.</span>reverse()
    <span style="color: #408080; font-style: italic"># Convert dates on the form &#39;YYYY-MM-DD&#39; to date objects</span>
    datefmt <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;%Y-%m-</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span>
    dates <span style="color: #666666">=</span> [datetime<span style="color: #666666">.</span>strptime(_date, datefmt)<span style="color: #666666">.</span>date()
             <span style="color: #008000; font-weight: bold">for</span> _date <span style="color: #AA22FF; font-weight: bold">in</span> dates]
    prices <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(prices)
    <span style="color: #008000; font-weight: bold">return</span> dates[<span style="color: #666666">1</span>:], prices[<span style="color: #666666">1</span>:]
</pre></div>
<p>
Although we work with three companies in this example, it is easy
and almost always a good idea to generalize the program to an
arbitrary number of companies. All we assume is that their
stock prices are in files with names of the form <code>stockprices_X.csv</code>,
where <code>X</code> is the company name.
With aid of the function call <code>glob.glob('stockprices_*.csv')</code>
we get a list of all such files. By looping over this list, extracting
the company name, and calling <code>read_file</code>, we can store the
dates and corresponding prices in dictionaries <code>dates</code> and <code>prices</code>,
indexed by the company name:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dates <span style="color: #666666">=</span> {};  prices <span style="color: #666666">=</span> {}
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">glob</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
filenames <span style="color: #666666">=</span> glob<span style="color: #666666">.</span>glob(<span style="color: #BA2121">&#39;stockprices_*.csv&#39;</span>)
companies <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> filenames:
    company <span style="color: #666666">=</span> filename[<span style="color: #666666">12</span>:<span style="color: #666666">-4</span>]
    d, p <span style="color: #666666">=</span> read_file(filename)
    dates[company] <span style="color: #666666">=</span> d
    prices[company] <span style="color: #666666">=</span> p
</pre></div>
<p>
The next step is to normalize the prices such that they coincide
on a certain date. We pick this date as the first month we have
data for the youngest company. In lists of <code>date</code> or <code>datetime</code>
objects, we can use Python's <code>max</code> and <code>min</code> function to extract
the newest and oldest date.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">first_months <span style="color: #666666">=</span> [dates[company][<span style="color: #666666">0</span>] <span style="color: #008000; font-weight: bold">for</span> company <span style="color: #AA22FF; font-weight: bold">in</span> dates]
normalize_date <span style="color: #666666">=</span> <span style="color: #008000">max</span>(first_months)
<span style="color: #008000; font-weight: bold">for</span> company <span style="color: #AA22FF; font-weight: bold">in</span> dates:
    index <span style="color: #666666">=</span> dates[company]<span style="color: #666666">.</span>index(normalize_date)
    prices[company] <span style="color: #666666">/=</span> prices[company][index]

<span style="color: #408080; font-style: italic"># Plot log of price versus years</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.dates</span> <span style="color: #008000; font-weight: bold">import</span> YearLocator, MonthLocator, DateFormatter

fig, ax <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots()
legends <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> company <span style="color: #AA22FF; font-weight: bold">in</span> prices:
    ax<span style="color: #666666">.</span>plot_date(dates[company], np<span style="color: #666666">.</span>log(prices[company]),
                 <span style="color: #BA2121">&#39;-&#39;</span>, label<span style="color: #666666">=</span>company)
    legends<span style="color: #666666">.</span>append(company)
ax<span style="color: #666666">.</span>legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
ax<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;logarithm of normalized value&#39;</span>)

<span style="color: #408080; font-style: italic"># Format the ticks</span>
years    <span style="color: #666666">=</span> YearLocator(<span style="color: #666666">5</span>)   <span style="color: #408080; font-style: italic"># major ticks every 5 years</span>
months   <span style="color: #666666">=</span> MonthLocator(<span style="color: #666666">6</span>)  <span style="color: #408080; font-style: italic"># minor ticks every 6 months</span>
yearsfmt <span style="color: #666666">=</span> DateFormatter(<span style="color: #BA2121">&#39;%Y&#39;</span>)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_major_locator(years)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_major_formatter(yearsfmt)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_minor_locator(months)
ax<span style="color: #666666">.</span>autoscale_view()
fig<span style="color: #666666">.</span>autofmt_xdate()

plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The normalized prices varies a lot, so to see the development over 30
years better, we decide to take the logarithm of the prices. The
plotting procedure is somewhat involved so the reader should take the
coming code more as a recipe than as a sequence of statement to really
understand:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.dates</span> <span style="color: #008000; font-weight: bold">import</span> YearLocator, MonthLocator, DateFormatter

fig, ax <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots()
legends <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> company <span style="color: #AA22FF; font-weight: bold">in</span> prices:
    ax<span style="color: #666666">.</span>plot_date(dates[company], np<span style="color: #666666">.</span>log(prices[company]),
                 <span style="color: #BA2121">&#39;-&#39;</span>, label<span style="color: #666666">=</span>company)
    legends<span style="color: #666666">.</span>append(company)
ax<span style="color: #666666">.</span>legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
ax<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;logarithm of normalized value&#39;</span>)

<span style="color: #408080; font-style: italic"># Format the ticks</span>
years    <span style="color: #666666">=</span> YearLocator(<span style="color: #666666">5</span>)   <span style="color: #408080; font-style: italic"># major ticks every 5 years</span>
months   <span style="color: #666666">=</span> MonthLocator(<span style="color: #666666">6</span>)  <span style="color: #408080; font-style: italic"># minor ticks every 6 months</span>
yearsfmt <span style="color: #666666">=</span> DateFormatter(<span style="color: #BA2121">&#39;%Y&#39;</span>)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_major_locator(years)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_major_formatter(yearsfmt)
ax<span style="color: #666666">.</span>xaxis<span style="color: #666666">.</span>set_minor_locator(months)
ax<span style="color: #666666">.</span>autoscale_view()
fig<span style="color: #666666">.</span>autofmt_xdate()

plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
</pre></div>
<p>
Figure <a href="#sec:files:fig:stockprices1">2</a> shows the resulting plot.
We observe that the normalized prices coincide when Google
entered the market, here at Sep 1, 2004. Note that there is a log scale
on the vertical axis. You may want to plot the real normalized prices
to get a stronger impression of the significant recent rise in value,
especially for Apple.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  The evolution of stock prices for three companies. <a name="sec:files:fig:stockprices1"></a> </p></center>
<p><img src="fig-files/stockprices1.png" align="bottom" width=400></p>
</center>

<h1 id="sec:files:str">Strings<a name="sec:files:str"></a></h1>

Many programs need to manipulate text. For example, when we read the
contents of a file into a string or list of strings (lines),
we may want to change parts of the
text in the string(s) - and maybe write out the modified text to a new file.
So far in this document we have converted parts of the text to numbers
and computed with the numbers. Now it is time to learn how to
manipulate the text strings themselves.

<h2 id="sec:files:stringop">Common operations on strings<a name="sec:files:stringop"></a></h2>

Python has a rich set of operations on string objects.
<!-- Suppose <code>s</code> is the string <code>Berlin: 18.4 C at 4 pm</code>. -->
Some of the most common operations are listed below.

<h3 id="___sec21">Substring specification <a name="___sec21"></a></h3>

The expression <code>s[i:j]</code> extracts the
substring starting with character number <code>i</code>
and ending with character number <code>j-1</code> (similarly to lists, <code>0</code> is the
index of the first character):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Berlin: 18.4 C at 4 pm&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s[<span style="color: #666666">8</span>:]     <span style="color: #408080; font-style: italic"># from index 8 to the end of the string</span>
<span style="color: #BA2121">&#39;18.4 C at 4 pm&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s[<span style="color: #666666">8</span>:<span style="color: #666666">12</span>]   <span style="color: #408080; font-style: italic"># index 8, 9, 10 and 11 (not 12!)</span>
<span style="color: #BA2121">&#39;18.4&#39;</span>
</pre></div>
<p>
A negative upper index
counts, as usual, from the right such that <code>s[-1]</code> is the last
element, <code>s[-2]</code> is the next last element, and so on.

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s[<span style="color: #666666">8</span>:<span style="color: #666666">-1</span>]
<span style="color: #BA2121">&#39;18.4 C at 4 p&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s[<span style="color: #666666">8</span>:<span style="color: #666666">-8</span>]
<span style="color: #BA2121">&#39;18.4 C&#39;</span>
</pre></div>

<h3 id="___sec22">Searching for substrings <a name="___sec22"></a></h3>

The call
<code>s.find(s1)</code> returns
the index where
the substring <code>s1</code> first appears in <code>s</code>. If the substring is
not found, -1 is returned.

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;Berlin&#39;</span>)  <span style="color: #408080; font-style: italic"># where does &#39;Berlin&#39; start?</span>
<span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;pm&#39;</span>)
<span style="color: #666666">20</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;Oslo&#39;</span>)    <span style="color: #408080; font-style: italic"># not found</span>
<span style="color: #666666">-1</span>
</pre></div>
<p>
Sometimes the aim is to just check if a string is contained in
another string, and then we can use the syntax:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;Berlin&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> s:
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;Oslo&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> s:
<span style="color: #008000">False</span>
</pre></div>
<p>
Here is a typical use of the latter construction in an <code>if</code> test:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;C&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> s:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;C found&#39;</span>
<span style="color: #666666">...</span> <span style="color: #008000; font-weight: bold">else</span>:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;no C&#39;</span>
<span style="color: #666666">...</span>
C found
</pre></div>
<p>
Two other convenient methods
for checking if a string starts with or ends with a specified string
are <code>startswith</code> and <code>endswith</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>startswith(<span style="color: #BA2121">&#39;Berlin&#39;</span>)
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>endswith(<span style="color: #BA2121">&#39;am&#39;</span>)
<span style="color: #008000">False</span>
</pre></div>

<h3 id="___sec23">Substitution <a name="___sec23"></a></h3>

The call
<code>s.replace(s1, s2)</code> replaces substring
<code>s1</code> by
<code>s2</code> everywhere in <code>s</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39; &#39;</span>, <span style="color: #BA2121">&#39;_&#39;</span>)
<span style="color: #BA2121">&#39;Berlin:_18.4_C__at_4_pm&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;Berlin&#39;</span>, <span style="color: #BA2121">&#39;Bonn&#39;</span>)
<span style="color: #BA2121">&#39;Bonn: 18.4 C at 4 pm&#39;</span>
</pre></div>
<p>
A variant of the last example, where several string operations are
put together, consists of replacing the text before the first colon:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>replace(s[:s<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;:&#39;</span>)], <span style="color: #BA2121">&#39;Bonn&#39;</span>)
<span style="color: #BA2121">&#39;Bonn: 18.4 C at 4 pm&#39;</span>
</pre></div>
<p>
Take a break at this point and convince yourself that you understand how we
specify the substring to be replaced!

<h3 id="___sec24">String splitting <a name="___sec24"></a></h3>

The call <code>s.split()</code> splits the string <code>s</code> into words separated by
whitespace (space, tabulator, or newline):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>split()
[<span style="color: #BA2121">&#39;Berlin:&#39;</span>, <span style="color: #BA2121">&#39;18.4&#39;</span>, <span style="color: #BA2121">&#39;C&#39;</span>, <span style="color: #BA2121">&#39;at&#39;</span>, <span style="color: #BA2121">&#39;4&#39;</span>, <span style="color: #BA2121">&#39;pm&#39;</span>]
</pre></div>
<p>
Splitting a string <code>s</code> into words separated by a text <code>t</code> can be
done by <code>s.split(t)</code>. For example, we may split with respect to colon:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;:&#39;</span>)
[<span style="color: #BA2121">&#39;Berlin&#39;</span>, <span style="color: #BA2121">&#39; 18.4 C at 4 pm&#39;</span>]
</pre></div>
<p>
We know that <code>s</code> contains a city name, a colon, a temperature,
and then <code>C</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Berlin: 18.4 C at 4 pm&#39;</span>
</pre></div>
<p>
With <code>s.splitlines()</code>, a multi-line string is split into
lines (very useful when a file has been read into a string and we want
a list of lines):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> t <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;1st line</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">2nd line</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">3rd line&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> t
<span style="color: #666666">1</span>st line
<span style="color: #666666">2</span>nd line
<span style="color: #666666">3</span>rd line
<span style="color: #666666">&gt;&gt;&gt;</span> t<span style="color: #666666">.</span>splitlines()
[<span style="color: #BA2121">&#39;1st line&#39;</span>, <span style="color: #BA2121">&#39;2nd line&#39;</span>, <span style="color: #BA2121">&#39;3rd line&#39;</span>]
</pre></div>

<h3 id="___sec25">Upper and lower case <a name="___sec25"></a></h3>

<code>s.lower()</code> transforms all characters to their lower case
equivalents, and <code>s.upper()</code> performs a similar transformation to
upper case letters:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>lower()
<span style="color: #BA2121">&#39;berlin: 18.4 c at 4 pm&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>upper()
<span style="color: #BA2121">&#39;BERLIN: 18.4 C AT 4 PM&#39;</span>
</pre></div>

<h3 id="___sec26">Strings are constant <a name="___sec26"></a></h3>

A string cannot be changed, i.e., any change always results in a new string.
Replacement of a character is not possible:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s[<span style="color: #666666">18</span>] <span style="color: #666666">=</span> <span style="color: #666666">5</span>
<span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">TypeError</span>: <span style="color: #BA2121">&#39;str&#39;</span> <span style="color: #008000">object</span> does <span style="color: #AA22FF; font-weight: bold">not</span> support item assignment
</pre></div>
<p>
If we want to replace <code>s[18]</code>, a new string must
be constructed, for example by keeping the substrings on
either side of <code>s[18]</code> and inserting a <code>'5'</code> in between:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s[:<span style="color: #666666">18</span>] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;5&#39;</span> <span style="color: #666666">+</span> s[<span style="color: #666666">19</span>:]
<span style="color: #BA2121">&#39;Berlin: 18.4 C at 5 pm&#39;</span>
</pre></div>

<h3 id="___sec27">Strings with digits only <a name="___sec27"></a></h3>

One can easily test whether a string contains digits only or not:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;214&#39;</span><span style="color: #666666">.</span>isdigit()
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;  214 &#39;</span><span style="color: #666666">.</span>isdigit()
<span style="color: #008000">False</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;2.14&#39;</span><span style="color: #666666">.</span>isdigit()
<span style="color: #008000">False</span>
</pre></div>

<h3 id="___sec28">Whitespace <a name="___sec28"></a></h3>

We can also check if a string contains spaces only by calling the
<code>isspace</code> method.
More precisely, <code>isspace</code> tests for <em>whitespace</em>, which means the
space character, newline, or the TAB character:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;    &#39;</span><span style="color: #666666">.</span>isspace()   <span style="color: #408080; font-style: italic"># blanks</span>
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;  </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>isspace()   <span style="color: #408080; font-style: italic"># newline</span>
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;  </span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> &#39;</span><span style="color: #666666">.</span>isspace()  <span style="color: #408080; font-style: italic"># TAB</span>
<span style="color: #008000">True</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #BA2121">&#39;&#39;</span><span style="color: #666666">.</span>isspace()       <span style="color: #408080; font-style: italic"># empty string</span>
<span style="color: #008000">False</span>
</pre></div>
<p>
The <code>isspace</code> is handy for testing for blank lines in files.
An alternative is to strip first and then test for an empty string:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> line <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;   </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> line<span style="color: #666666">.</span>strip() <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;&#39;</span>
<span style="color: #008000">True</span>
</pre></div>
<p>
Stripping off leading and/or trailing spaces in a string is sometimes useful:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> s <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;   text with leading/trailing space   </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>strip()
<span style="color: #BA2121">&#39;text with leading/trailing space&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>lstrip()   <span style="color: #408080; font-style: italic"># left strip</span>
<span style="color: #BA2121">&#39;text with leading/trailing space   </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> s<span style="color: #666666">.</span>rstrip()   <span style="color: #408080; font-style: italic"># right strip</span>
<span style="color: #BA2121">&#39;   text with leading/trailing space&#39;</span>
</pre></div>
<p>
<a name="sec:files:join"></a>

<h3 id="___sec29">Joining strings <a name="___sec29"></a></h3>

The opposite of the <code>split</code> method is <code>join</code>, which joins elements
in a list of strings with a specified delimiter in between.
That is,
the following two types of statements are inverse operations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t <span style="color: #666666">=</span> delimiter<span style="color: #666666">.</span>join(words)
words <span style="color: #666666">=</span> t<span style="color: #666666">.</span>split(delimiter)
</pre></div>
<p>
An example on using <code>join</code> may be

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> strings <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;Newton&#39;</span>, <span style="color: #BA2121">&#39;Secant&#39;</span>, <span style="color: #BA2121">&#39;Bisection&#39;</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> t <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join(strings)
<span style="color: #666666">&gt;&gt;&gt;</span> t
<span style="color: #BA2121">&#39;Newton, Secant, Bisection&#39;</span>
</pre></div>
<p>
As an illustration of the usefulness of <code>split</code> and <code>join</code>,
we want to remove the first two words on a line.
This task can be done by
first splitting the line into words and then joining the words of interest:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> line <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;This is a line of words separated by space&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
<span style="color: #666666">&gt;&gt;&gt;</span> line2 <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join(words[<span style="color: #666666">2</span>:])
<span style="color: #666666">&gt;&gt;&gt;</span> line2
<span style="color: #BA2121">&#39;a line of words separated by space&#39;</span>
</pre></div>
<p>
There are many more methods in string objects. All methods are described
in the
<a href="http://docs.python.org/2/library/stdtypes.html#string-methods" target="_self">String Methods</a> section of the Python Standard Library online document.

<h2 id="sec:files:pairs">Example: Reading pairs of numbers<a name="sec:files:pairs"></a></h2>

<h3 id="___sec31">Problem <a name="___sec31"></a></h3>

Suppose we have a file consisting of pairs of real numbers, i.e.,
text of the form \( (a,b) \), where \( a \) and \( b \) are real numbers.
This notation for a pair of numbers is often used for points in the
plane, vectors in the plane, and complex
numbers. A sample file may look as follows:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">(1.3,0)    (-1,2)    (3,-1.5)
(0,1)      (1,0)     (1,1)
(0,-0.01)  (10.5,-1) (2.5,-2.5)
</pre></div>
<p>
The file can be found as <code>read_pairs1.dat</code>.  Our task is to read this
text into a nested list <code>pairs</code> such that <code>pairs[i]</code> holds the pair
with index <code>i</code>, and this pair is a tuple of two <code>float</code> objects.  We
assume that there are no blanks inside the parentheses of a pair of
numbers (we rely on a split operation, which would otherwise not work).

<h3 id="___sec32">Solution <a name="___sec32"></a></h3>

To solve this programming problem, we can read in the file line by
line; for each line: split the line into words (i.e., split with
respect to whitespace); for each word: strip off the parentheses,
split with respect to comma, and convert the resulting two words to
floats.  Our brief algorithm can be almost directly translated to
Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Load the file into list of lines</span>
<span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;read_pairs1.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> infile:
    lines <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readlines()

<span style="color: #408080; font-style: italic"># Analyze the contents of each line</span>
pairs <span style="color: #666666">=</span> []   <span style="color: #408080; font-style: italic"># list of (n1, n2) pairs of numbers</span>
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines:
    words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
    <span style="color: #008000; font-weight: bold">for</span> word <span style="color: #AA22FF; font-weight: bold">in</span> words:
        word <span style="color: #666666">=</span> word[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]  <span style="color: #408080; font-style: italic"># strip off parenthesis</span>
        n1, n2 <span style="color: #666666">=</span> word<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;,&#39;</span>)
        n1 <span style="color: #666666">=</span> <span style="color: #008000">float</span>(n1);  n2 <span style="color: #666666">=</span> <span style="color: #008000">float</span>(n2)
        pair <span style="color: #666666">=</span> (n1, n2)
        pairs<span style="color: #666666">.</span>append(pair)  <span style="color: #408080; font-style: italic"># add 2-tuple to last row</span>
</pre></div>
<p>
This code is available in the file
<a href="http://tinyurl.com/pwyasaa/files/read_pairs1.py" target="_self"><tt>read_pairs1.py</tt></a>.
The <code>width</code> statement is the modern Python way of reading files,
see the section ref{sec:files:reading:other},
with the advantage that we do not need to think about closing the file.
Figure <a href="#sec:files:fig1">3</a> shows a snapshot of the state of the
variables in the program after having treated the first line.
You should explain each line in the program to yourself, and
compare your understanding with the figure.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of the variables in the <code>read_pairs.py</code> program after the first pass in the loop over words in the first line of the data file. <a name="sec:files:fig1"></a> </p></center>
<p><img src="fig-files/lumpy_read_pairs.png" align="bottom" width=400></p>
</center>

<p>
The output from the program becomes

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[(1.3, 0.0),
 (-1.0, 2.0),
 (3.0, -1.5),
 (0.0, 1.0),
 (1.0, 0.0),
 (1.0, 1.0),
 (0.0, -0.01),
 (10.5, -1.0),
 (2.5, -2.5)]
</pre></div>
</blockquote><p>
We remark that our solution to this programming problem relies heavily
on the fact that spaces inside the parentheses are not allowed.  If
spaces were allowed, the simple split to obtain the pairs on a line as
words would not work. What can we then do?

<p>
We can first strip off all blanks on a line, and then observe that the
pairs are separated by the text <code>')('</code>.  The first and last pair on a
line will have an extra parenthesis that we need to remove. The rest
of code is similar to the previous code and can be found in
<a href="http://tinyurl.com/pwyasaa/files/read_pairs2.py" target="_self"><tt>read_pairs2.py</tt></a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;read_pairs2.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> infile:
    lines <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readlines()

<span style="color: #408080; font-style: italic"># Analyze the contents of each line</span>
pairs <span style="color: #666666">=</span> []   <span style="color: #408080; font-style: italic"># list of (n1, n2) pairs of numbers</span>
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines:
    line <span style="color: #666666">=</span> line<span style="color: #666666">.</span>strip()  <span style="color: #408080; font-style: italic"># remove whitespace such as newline</span>
    line <span style="color: #666666">=</span> line<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39; &#39;</span>, <span style="color: #BA2121">&#39;&#39;</span>)  <span style="color: #408080; font-style: italic"># remove all blanks</span>
    words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;)(&#39;</span>)
    <span style="color: #408080; font-style: italic"># strip off leading/trailing parenthesis in first/last word:</span>
    words[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> words[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>:]      <span style="color: #408080; font-style: italic"># (-1,3  -&gt;  -1,3</span>
    words[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> words[<span style="color: #666666">-1</span>][:<span style="color: #666666">-1</span>]   <span style="color: #408080; font-style: italic"># 8.5,9) -&gt;  8.5,9</span>
    <span style="color: #008000; font-weight: bold">for</span> word <span style="color: #AA22FF; font-weight: bold">in</span> words:
        n1, n2 <span style="color: #666666">=</span> word<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;,&#39;</span>)
        n1 <span style="color: #666666">=</span> <span style="color: #008000">float</span>(n1);  n2 <span style="color: #666666">=</span> <span style="color: #008000">float</span>(n2)
        pair <span style="color: #666666">=</span> (n1, n2)
        pairs<span style="color: #666666">.</span>append(pair)
</pre></div>
<p>
The program can be tested on the file <code>read_pairs2.dat</code>:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">   (1.3 , 0)    (-1 , 2 )    (3, -1.5)
(0 , 1)      ( 1, 0)     ( 1 , 1 )
(0,-0.01)  (10.5,-1) (2.5, -2.5)
</pre></div>
<p>
A third approach is to notice that if the pairs were separated
by commas,

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">(1, 3.0),    (-1, 2),    (3, -1.5)
(0, 1),      (1, 0),     (1, 1)
</pre></div>
</blockquote><p>
the file text is very close to the Python syntax of a list
of 2-tuples. By adding enclosing brackets, plus a comma at the
end of each line,

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[(1, 3.0),    (-1, 2),    (3, -1.5),
(0, 1),      (1, 0),     (1, 1),]
</pre></div>
</blockquote><p>
we have a string to which we can apply <code>eval</code> to get the <code>pairs</code> list
directly.  Here is the code doing this (program <a href="http://tinyurl.com/pwyasaa/files/read_pairs3.py" target="_self"><tt>read_pairs3.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;read_pairs3.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> infile:
    listtext <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;[&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        <span style="color: #408080; font-style: italic"># add line, without \n (line[:-1]), with a trailing comma:</span>
        listtext <span style="color: #666666">+=</span> line[:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;, &#39;</span>
listtext <span style="color: #666666">=</span> listtext <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;]&#39;</span>
pairs <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(listtext)
</pre></div>
<p>
In general, it is a good idea to construct file formats that are as close
as possible to valid Python syntax such that one can take advantage
of the <code>eval</code> or <code>exec</code> functions to turn text into &quot;live objects&quot;.

<h2 id="___sec33">Example: Reading coordinates <a name="___sec33"></a></h2>

<h3 id="___sec34">Problem <a name="___sec34"></a></h3>

Suppose we have a file with coordinates \( (x,y,z) \)
in three-dimensional space. The file format looks as follows:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  x=-1.345      y= 0.1112      z= 9.1928
  x=-1.231      y=-0.1251      z= 1001.2
  x= 0.100      y= 1.4344E+6   z=-1.0100
  x= 0.200      y= 0.0012      z=-1.3423E+4
  x= 1.5E+5     y=-0.7666      z= 1027
</pre></div>
<p>
The goal is to read this file and create a list with <code>(x,y,z)</code>
3-tuples, and thereafter convert the nested list to a two-dimensional
array with which we can compute.

<p>
Note that there is sometimes a space between the <code>=</code> signs and the
following number and sometimes not. Splitting with respect to space and
extracting every second word is therefore not an option.
We shall present three solutions.

<h3 id="___sec35">Solution 1: substring extraction <a name="___sec35"></a></h3>

The file format looks very regular with the <code>x=</code>, <code>y=</code>,
and <code>z=</code> texts starting in the same columns at every line.
By counting characters, we realize that the <code>x=</code> text starts
in column 2, the <code>y=</code> text starts in column 16, while the
<code>z=</code> text starts in column 31. Introducing

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x_start <span style="color: #666666">=</span> <span style="color: #666666">2</span>
y_start <span style="color: #666666">=</span> <span style="color: #666666">16</span>
z_start <span style="color: #666666">=</span> <span style="color: #666666">31</span>
</pre></div>
<p>
the three numbers in a <code>line</code> string are obtained as the substrings

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> line[x_start<span style="color: #666666">+2</span>:y_start]
y <span style="color: #666666">=</span> line[y_start<span style="color: #666666">+2</span>:z_start]
z <span style="color: #666666">=</span> line[z_start<span style="color: #666666">+2</span>:]
</pre></div>
<p>
The following code, found in file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v1.py" target="_self"><tt>file2coor_v1.py</tt></a>,
creates the <code>coor</code> array with shape \( (n,3) \),
where \( n \) is the number of \( (x,y,z) \) coordinates.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;xyz.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
coor <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># list of (x,y,z) tuples</span>
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
    x_start <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    y_start <span style="color: #666666">=</span> <span style="color: #666666">16</span>
    z_start <span style="color: #666666">=</span> <span style="color: #666666">31</span>
    x <span style="color: #666666">=</span> line[x_start<span style="color: #666666">+2</span>:y_start]
    y <span style="color: #666666">=</span> line[y_start<span style="color: #666666">+2</span>:z_start]
    z <span style="color: #666666">=</span> line[z_start<span style="color: #666666">+2</span>:]
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;debug: x=&quot;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot;, y=&quot;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot;, z=&quot;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot;&#39;</span> <span style="color: #666666">%</span> (x,y,z)
    coor<span style="color: #666666">.</span>append((<span style="color: #008000">float</span>(x), <span style="color: #008000">float</span>(y), <span style="color: #008000">float</span>(z)))
infile<span style="color: #666666">.</span>close()

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
coor <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(coor)
<span style="color: #008000; font-weight: bold">print</span> coor<span style="color: #666666">.</span>shape, coor
</pre></div>
<p>
The <code>print</code> statement inside the loop
is always wise to include when doing string manipulations,
simply
because counting indices for substring limits quickly leads to errors.
Running the program, the output from the loop looks like this

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">debug: x=&quot;-1.345   &quot;, y=&quot; 0.1112   &quot;, z=&quot; 9.1928
&quot;
</pre></div>
</blockquote><p>
for the first line in the file. The double quotes show the exact
extent of the extracted coordinates. Note that the last quote
appears on the next line. This is because <code>line</code> has a newline
at the end (this newline must be there to define the end of the line),
and the substring <code>line[z_start:]</code> contains the newline at the
of <code>line</code>. Writing <code>line[z_start:-1]</code> would leave the
newline out of the \( z \) coordinate. However, this has no effect in
practice since we transform the substrings to <code>float</code>, and an extra
newline or other blanks make no harm.

<p>
The <code>coor</code> object at the end of the program has the value

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[ -1.34500000e+00   1.11200000e-01   9.19280000e+00]
 [ -1.23100000e+00  -1.25100000e-01   1.00120000e+03]
 [  1.00000000e-01   1.43440000e+06  -1.01000000e+00]
 [  2.00000000e-01   1.20000000e-03  -1.34230000e+04]
 [  1.50000000e+05  -7.66600000e-01   1.02700000e+03]]
</pre></div>
</blockquote><h3 id="___sec36">Solution 2: string search <a name="___sec36"></a></h3>

One problem with the solution approach above is that the program
will not work if the file format is subject to a
change in the
column positions of <code>x=</code>, <code>y=</code>, or <code>z=</code>.
Instead of hardcoding numbers for the column positions, we can use
the <code>find</code> method in string objects to locate these column positions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x_start <span style="color: #666666">=</span> line<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;x=&#39;</span>)
y_start <span style="color: #666666">=</span> line<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;y=&#39;</span>)
z_start <span style="color: #666666">=</span> line<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;z=&#39;</span>)
</pre></div>
<p>
The rest of the code is similar to the complete program listed above,
and the complete code is stored in the file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v2.py" target="_self"><tt>file2coor_v2.py</tt></a>.

<h3 id="___sec37">Solution 3: string split <a name="___sec37"></a></h3>

String splitting is a powerful tool, also in the present case.
Let us split with respect to the equal sign. The first line in the file
then gives us the words

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[&#39;x&#39;, &#39;-1.345   y&#39;, &#39; 0.1112   z&#39;, &#39; 9.1928&#39;]
</pre></div>
</blockquote><p>
We throw away the first word, and strip off the last character in the
next word. The final word can be used as is. The complete program
is found in the file
<a href="http://tinyurl.com/pwyasaa/files/file2coor_v3.py" target="_self"><tt>file2coor_v3.py</tt></a> and looks like

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;xyz.dat&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
coor <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># list of (x,y,z) tuples</span>
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
    words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;=&#39;</span>)
    x <span style="color: #666666">=</span> <span style="color: #008000">float</span>(words[<span style="color: #666666">1</span>][:<span style="color: #666666">-1</span>])
    y <span style="color: #666666">=</span> <span style="color: #008000">float</span>(words[<span style="color: #666666">2</span>][:<span style="color: #666666">-1</span>])
    z <span style="color: #666666">=</span> <span style="color: #008000">float</span>(words[<span style="color: #666666">3</span>])
    coor<span style="color: #666666">.</span>append((x, y, z))
infile<span style="color: #666666">.</span>close()

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
coor <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(coor)
<span style="color: #008000; font-weight: bold">print</span> coor<span style="color: #666666">.</span>shape, coor
</pre></div>
<p>
More sophisticated examples of string operations appear in
the section <a href="#sec:files:url:interpret">Example: Extracting data from HTML</a>.

<h1 id="sec:files:webtxt">Reading data from web pages<a name="sec:files:webtxt"></a></h1>

Python has a module <code>urllib</code> which makes it possible to read data from
a web page as easily as
we can read data from an ordinary file. (In principle this is
true, but in practice
the text in web pages tend to be much more complicated than the text
in the files we have treated so far.)
Before we do this, a few concepts from the Internet world must be touched.

<h2 id="sec:files:HTMLintro">About web pages<a name="sec:files:HTMLintro"></a></h2>

Web pages are viewed with a web browser. There are many browsers:
Firefox, Internet Explorer, Safari, Opera, and Google Chrome to mention
the most famous.
Any web page you visit is associated with an address, usually something like

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://www.some.where.net/some/file.html
</pre></div>
</blockquote><p>
This type of web address is called
a URL (Uniform Resource Locator) or
URI (Uniform Resource Identifier).
(We stick to the term URL in this document because Python's tools for
accessing resources on the Internet have <code>url</code> as part of
module and function names.)
The graphics you see in a web browser, i.e., the web page you see with
your eyes, is produced by a series of commands that specifies
the text on the page, the images, buttons to be pressed, etc.
Roughly speaking, these commands are like statements in computer programs.
The commands are stored in a text file and follow rules in a language,
exactly as you are used to when writing statements in a programming language.

<p>
The common language for defining web pages is HTML.
A web page is then simply a text file with text containing
HTML commands. Instead of a physical file, the web page can also be
the output text from a program. In that case the URL is the name of the
program file.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Example of what a very simple HTML file looks like in a web browser. <a name="sec:io:webpagefig"></a> </p></center>
<p><img src="fig-files/simple_webpage.png" align="bottom" width=400></p>
</center>

<p>
The web browser interprets the text and the HTML commands, and then
decides how to display the
information visually. Let us demonstrate this for a very simple
web page shown in Figure <a href="#sec:io:webpagefig">4</a>.
This page was produced by the following text with embedded HTML commands:

<p>

<!-- code=html (!bc htmlpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">&lt;html&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;body</span> <span style="color: #7D9029">bgcolor=</span><span style="color: #BA2121">&quot;orange&quot;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;h1&gt;</span>A Very Simple HTML Page<span style="color: #008000; font-weight: bold">&lt;/h1&gt;</span> <span style="color: #408080; font-style: italic">&lt;!-- headline --&gt;</span>
Web pages are written in a language called
<span style="color: #008000; font-weight: bold">&lt;a</span> <span style="color: #7D9029">href=</span><span style="color: #BA2121">&quot;http://www.w3.org/MarkUp/Guide/&quot;</span><span style="color: #008000; font-weight: bold">&gt;</span>HTML<span style="color: #008000; font-weight: bold">&lt;/a&gt;</span>.
Ordinary text is written as ordinary text, but when we
need links, headlines, lists,
<span style="color: #008000; font-weight: bold">&lt;ul&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;li&gt;&lt;em&gt;</span>emphasized words<span style="color: #008000; font-weight: bold">&lt;/em&gt;</span>, or
<span style="color: #008000; font-weight: bold">&lt;li&gt;</span> <span style="color: #008000; font-weight: bold">&lt;b&gt;</span>boldface text<span style="color: #008000; font-weight: bold">&lt;/b&gt;</span>, 
<span style="color: #008000; font-weight: bold">&lt;/ul&gt;</span>
we need to embed the text inside HTML tags. We can also
insert GIF or PNG images, taken from other Internet sites, 
if desired.
<span style="color: #008000; font-weight: bold">&lt;hr&gt;</span> <span style="color: #408080; font-style: italic">&lt;!-- horizontal line --&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;img</span> <span style="color: #7D9029">src=</span><span style="color: #BA2121">&quot;http://www.simula.no/simula_logo.gif&quot;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;/body&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;/html&gt;</span>
</pre></div>
<p>
A typical HTML command consists of an opening and a closing <em>tag</em>.
For example, emphasized text is specified by enclosing the text
inside <code>em</code> (emphasize) tags:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&lt;</span>em<span style="color: #666666">&gt;</span>emphasized words<span style="color: #666666">&lt;/</span>em<span style="color: #666666">&gt;</span>
</pre></div>
<p>
The opening tag is enclosed in less than and greater than signs, while
the closing tag has an additional forward slash before the tag name.

<p>
In the HTML file we see an opening and closing <code>html</code> tag around the
whole text in the file. Similarly, there is a pair of <code>body</code> tags,
where the first one also has a parameter <code>bgcolor</code> which can be used
to specify a background color in the web page.  Section headlines are
specified by enclosing the headline text inside <code>h1</code> tags. Subsection
headlines apply <code>h2</code> tags, which results in a smaller font compared
with <code>h1</code> tags.  Comments appear inside <code><!--</code> and <code>--></code>.  Links to
other web pages are written inside <code>a</code> tags, with an argument <code>href</code>
for the link's web address.  Lists apply the <code>ul</code> (unordered list)
tag, while each item is written with just an opening tag <code>li</code> (list
item), but no closing tag is necessary. Images are also specified with
just an opening tag having name <code>img</code>, and the image file is given as
a file name or URL of a file, enclosed in double quotes, as the <code>src</code>
parameter.

<p>
The ultra-quick HTML course in the previous paragraphs gives a glimpse
of how web pages can be constructed.
One can either write the HTML
file by hand in a pure text editor, or one can use programs such as
Dream Weaver to help design the page graphically in a user-friendly
environment, and then the program can automatically
generate the right HTML syntax in files.

<h2 id="sec:files:urllib">How to access web pages in programs<a name="sec:files:urllib"></a></h2>

Why is it useful to know some HTML and how web pages are constructed?
The reason is that the web is full of information that we can
get access to through programs and use in new contexts. What we can get
access to is not the visual web page you see, but the underlying HTML
file. The information you see on the screen appear in text form in
the HTML file, and by extracting text, we can get hold of the
text's information in a program.

<p>
Given the URL as a string stored in a variable,
there are two ways of accessing the HTML text in a Python program:

<h3 id="___sec41">Alternative 1 <a name="___sec41"></a></h3>

Download the HTML file and store it as a local file with a given name,
say <code>webpage.html</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">urllib</span>
url <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;http://www.simula.no/research/scientific/cbc&#39;</span>
urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;webpage.html&#39;</span>)
</pre></div>

<h3 id="___sec42">Alternative 2 <a name="___sec42"></a></h3>

Open the HTML file as a file-like object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> urllib<span style="color: #666666">.</span>urlopen(url)
</pre></div>
<p>
This <code>infile</code> object has methods such as <code>read</code>, <code>readline</code>, and
<code>readlines</code>.

<h2 id="sec:files:url:weather">Example: Reading pure text files<a name="sec:files:url:weather"></a></h2>

Some web pages are just pure text files. Extracting the data from such
pages are as easy as reading ordinary text files. Here is an example
of historic weather data from the UK:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://www.metoffice.gov.uk/climate/uk/stationdata/
</pre></div>
</blockquote><p>
We may choose a station, say Oxford, which directs us to the page

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://www.metoffice.gov.uk/climate/uk/stationdata/oxforddata.txt
</pre></div>
</blockquote><p>
We can download this data file by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">urllib</span>
url <span style="color: #666666">=</span> \ 
<span style="color: #BA2121">&#39;http://www.metoffice.gov.uk/climate/uk/stationdata/oxforddata.txt&#39;</span>
urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Oxford.txt&#39;</span>)
</pre></div>
<p>
The files looks as follows:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Oxford
Location: 4509E 2072N, 63 metres amsl
Estimated data is marked with a * after the value.
Missing data (more than 2 days missing in month) is marked by  ---.
Sunshine data taken from an automatic ...
   yyyy  mm   tmax    tmin      af    rain     sun
              degC    degC    days      mm   hours
   1853   1    8.4     2.7       4    62.8     ---
   1853   2    3.2    -1.8      19    29.3     ---
   1853   3    7.7    -0.6      20    25.9     ---
   1853   4   12.6     4.5       0    60.1     ---
   1853   5   16.8     6.1       0    59.5     ---

...

   2010   1    4.7    -1.0      17    56.4    68.2
   2010   2    7.1     1.3       7    79.8    59.3
   2010   3   11.3     3.2       8    47.6   130.2
   2010   4   15.8     4.9       0    25.5   209.5
   2010   5   17.6     7.3       0    28.6   207.4
   2010   6   23.0    11.1       0    34.5   230.5
   2010   7   23.3*   14.1*      0*   24.4*  184.4*  Provisional
   2010   8   21.4    12.0       0   146.2   123.8   Provisional
   2010   9   19.0    10.0       0    48.1   118.6   Provisional
   2010  10   14.6     7.4       2    43.5   128.8   Provisional
</pre></div>
<p>
After the 7 header lines the data consists of 7 or 8 columns of
numbers, the 8th being of no interest.
Some numbers may have <code>*</code> or <code>#</code> appended to them,
but this character must be stripped off before using the number.
The columns contain the year, the month number (1-12), average maximum
temperature, average minimum temperature, total number of days of
air frost (<code>af</code>) during the month,
total rainfall during the month, and the total number
of hours with sun during the month. The temperature averages are taken
over the maximum and minimum temperatures for all days in the month.
Unavailable data are marked by three dashes.

<p>
The data can be conveniently stored in a dictionary with, e.g.,
three main keys: place (name), location (the info on the 2nd),
and data. The latter is a dictionary with two keys: year and month.

<p>
The following program creates the <code>data</code> dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(local_file, <span style="color: #BA2121">&#39;r&#39;</span>)
data <span style="color: #666666">=</span> {}
data[<span style="color: #BA2121">&#39;place&#39;</span>] <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readline()<span style="color: #666666">.</span>strip()
data[<span style="color: #BA2121">&#39;location&#39;</span>] <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readline()<span style="color: #666666">.</span>strip()
<span style="color: #408080; font-style: italic"># Skip the next 5 lines</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">5</span>):
    infile<span style="color: #666666">.</span>readline()

data[<span style="color: #BA2121">&#39;data&#39;</span>] <span style="color: #666666">=</span>{}
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
    columns <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()

    year <span style="color: #666666">=</span> <span style="color: #008000">int</span>(columns[<span style="color: #666666">0</span>])
    month <span style="color: #666666">=</span> <span style="color: #008000">int</span>(columns[<span style="color: #666666">1</span>])

    <span style="color: #008000; font-weight: bold">if</span> columns[<span style="color: #666666">-1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Provisional&#39;</span>:
        <span style="color: #008000; font-weight: bold">del</span> columns[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #008000">len</span>(columns)):
        <span style="color: #008000; font-weight: bold">if</span> columns[i] <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;---&#39;</span>:
            columns[i] <span style="color: #666666">=</span> <span style="color: #008000">None</span>
        <span style="color: #008000; font-weight: bold">elif</span> columns[i][<span style="color: #666666">-1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;*&#39;</span> <span style="color: #AA22FF; font-weight: bold">or</span> columns[i][<span style="color: #666666">-1</span>] <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;#&#39;</span>:
            <span style="color: #408080; font-style: italic"># Strip off trailing character</span>
            columns[i] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(columns[i][:<span style="color: #666666">-1</span>])
        <span style="color: #008000; font-weight: bold">else</span>:
            columns[i] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(columns[i])

    tmax, tmin, air_frost, rain, sun <span style="color: #666666">=</span> columns[<span style="color: #666666">2</span>:]

    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> year <span style="color: #AA22FF; font-weight: bold">in</span> data[<span style="color: #BA2121">&#39;data&#39;</span>]:
        data[<span style="color: #BA2121">&#39;data&#39;</span>][year] <span style="color: #666666">=</span> {}
    data[<span style="color: #BA2121">&#39;data&#39;</span>][year][month] <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;tmax&#39;</span>: tmax,
                                 <span style="color: #BA2121">&#39;tmin&#39;</span>: tmin,
                                 <span style="color: #BA2121">&#39;air frost&#39;</span>: air_frost,
                                 <span style="color: #BA2121">&#39;sun&#39;</span>: sun}
</pre></div>
<p>
The code is available in the file
<a href="http://tinyurl.com/pwyasaa/files/historic_weather.py" target="_self"><tt>historic_weather.py</tt></a>.

<p>
With a few lines of code, we can extract the data we want, say a
two-dimensional array of the number of sun hours in a month (these data
are available from year 1929):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">sun <span style="color: #666666">=</span> [[data[<span style="color: #BA2121">&#39;data&#39;</span>][y][m][<span style="color: #BA2121">&#39;sun&#39;</span>] <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,<span style="color: #666666">13</span>)] \ 
       <span style="color: #008000; font-weight: bold">for</span> y <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1929</span>, <span style="color: #666666">2010</span>)]
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
sun <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(sun)
</pre></div>
<p>
One can now do analysis of the data as exemplified in
the section ref{sec:looplist:summary:ex} and ref{sec:plot:ex33}.

<h2 id="sec:files:url:interpret">Example: Extracting data from HTML<a name="sec:files:url:interpret"></a></h2>

Very often, interesting data in a web page appear inside HTML code.
We then need to interpret the text using string operations and store
the data in variables. An example will clarify the principle.

<p>
The web site <code>www.worldclimate.com</code> contains data on temperature and
rainfall in a large number of cities around the world.
For example,

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://www.worldclimate.com/cgi-bin/data.pl?ref=N38W009+2100+08535W
</pre></div>
</blockquote><p>
contains a table of the average rainfall for each month of the year
in the town Lisbon, Portugal.
Our task is to download this web page and extract the tabular data
(rainfall per month) in a list.

<p>
Downloading the file is done with <code>urllib</code> as explained in
the sections <a href="#sec:files:urllib">How to access web pages in programs</a> and <a href="#sec:files:url:weather">Example: Reading pure text files</a>.
Before attempting to read and interpret the text in the file, we need
to look at the HTML code to find the interesting parts and determine
how we can extract the data.
The table with the rainfall data appears in the middle of the file.
A sketch of the relevant HTML code goes as follows:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&lt;p&gt;Weather station &lt;strong&gt;LISBOA&lt;/strong&gt; ...
&lt;tr&gt;&lt;th align=right&gt;&lt;th&gt;  Jan&lt;th&gt;  Feb&lt;th&gt; ... &lt;br&gt;
&lt;tr&gt;&lt;td&gt; mm &lt;td align=right&gt; 95.2 &lt;td align=right&gt; 86.7 ...&lt;br&gt;
&lt;tr&gt;&lt;td&gt;inches &lt;td align=right&gt;3.7&lt;td align=right&gt;3.4 ...&lt;br&gt;
</pre></div>
<p>
Our task is to walk through the file line by line and stop for processing
the first and third line above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;Lisbon_rainfall.html&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
rainfall <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;Weather station&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> line:
        station <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;&lt;/strong&gt;&#39;</span>)[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;&lt;strong&gt;&#39;</span>)[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;&lt;td&gt; mm &lt;td&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> line:
        data <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;&lt;td align=right&gt;&#39;</span>)
</pre></div>
<p>
The resulting <code>data</code> list looks like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[<span style="color: #BA2121">&#39;&lt;tr&gt;&lt;td&gt; mm &#39;</span>, <span style="color: #BA2121">&#39; 95.2 &#39;</span>, <span style="color: #666666">...</span>, <span style="color: #BA2121">&#39;702.4&lt;br&gt; </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>]
</pre></div>
<p>
To process this list further, we strip off the <code><br>...</code> part of
the last element:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">        data[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> data[<span style="color: #666666">-1</span>]<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;&lt;br&gt;&#39;</span>)[<span style="color: #666666">0</span>]
</pre></div>
<p>
Then we drop the first element and convert the others to <code>float</code>
objects:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">        data <span style="color: #666666">=</span> [<span style="color: #008000">float</span>(x) <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> data[<span style="color: #666666">1</span>:]]
</pre></div>
<p>
Now we have the rainfall data for each month as a list of real
numbers. The complete program appears in the file
<a href="http://tinyurl.com/pwyasaa/files/Lisbon_rainfall.py" target="_self"><tt>Lisbon_rainfall.py</tt></a>.
The recipe provided in this example can be used to interpret many other
types of web pages where HTML code and data are wired together.

<p>
<!-- send SMS to mobile phone -->
<!-- <a href="http://www.gammu.org/wiki/index.php" target="_self"><tt>http://www.gammu.org/wiki/index.php</tt></a>?title=Main_Page -->

<h2 id="sec:files:encoding">Handling non-English text<a name="sec:files:encoding"></a></h2>

By default, Python only accepts English characters in a program file.
Comments and strings in other languages, containing non-English characters,
requires a special comment line before any non-English characters appears:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># -*- coding: utf-8 -*-</span>
</pre></div>
<p>
This line specifies that the file applies the UTF-8 encoding. Alternative
encodings are UTF-16 and latin-1, depending on what your computer system
supports. UTF-8 is most common nowadays.

<p>
There are two types of strings in Python: plain strings (known as
byte strings) with type <code>str</code>
and unicode strings with type <code>unicode</code>. Plain strings suffice as long
as you are writing English text only. A string is then just a
series of bytes representing integers between 0 and 255.
The first characters corresponding to the numbers 0 to 127 constitute
the ASCII set. These can be printed out:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, <span style="color: #666666">128</span>):
    <span style="color: #008000; font-weight: bold">print</span> i, <span style="color: #008000">chr</span>(i)
</pre></div>
<p>
The keys on an English keyboard can be recognized from <code>i=32</code> to <code>i=126</code>.
The next numbers are used to represent non-English characters.

<p>
Texts with non-English
characters are recommended to be represented by unicode strings.
This is the default string type in Python 3, while in Python
2 we need to explicitly annotate a string as unicode by
a <code>u</code> prefix as in <code>s = u'my text'</code>.

<p>
We shall now explore plain strings and unicode strings and will for
that purpose need a help function for displaying a string in the terminal
window, printing the type of string, dumping the exact content of
the string, and telling us the length of the string in bytes:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check</span>(s):
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> \ 
          (s, s<span style="color: #666666">.</span>__class__<span style="color: #666666">.</span>__name__, <span style="color: #008000">repr</span>(s), <span style="color: #008000">len</span>(s))
</pre></div>
<p>
Let us start with a German character typed with a German keyboard:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Gauss <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;C. F. Gau&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(Gauss)
C<span style="color: #666666">.</span> F<span style="color: #666666">.</span> Gau, <span style="color: #008000">str</span>: <span style="color: #BA2121">&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xc3\x9f</span><span style="color: #BA2121">&#39;</span> (<span style="color: #666666">11</span>)
</pre></div>
<p>
Observe that there are 10 characters in the string, but <code>len(Gauss)</code>
is 11. We can write each character:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> char <span style="color: #AA22FF; font-weight: bold">in</span> Gauss:
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">ord</span>(char),
<span style="color: #666666">...</span>
<span style="color: #666666">67</span> <span style="color: #666666">46</span> <span style="color: #666666">32</span> <span style="color: #666666">70</span> <span style="color: #666666">46</span> <span style="color: #666666">32</span> <span style="color: #666666">71</span> <span style="color: #666666">97</span> <span style="color: #666666">117</span> <span style="color: #666666">195</span> <span style="color: #666666">159</span>
</pre></div>
<p>
The last character in the <code>Gauss</code> object, the special German character,
is represented
by two bytes: 195 and 159. The other characters are in the
range 0-127.

<p>
The <code>Gauss</code> object above is a plain Python 2 (byte) string. We can define
the string as unicode in Python 2:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Gauss <span style="color: #666666">=</span> <span style="color: #BA2121">u&#39;C. F. Gau&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(Gauss)
C<span style="color: #666666">.</span> F<span style="color: #666666">.</span> Gau, <span style="color: #008000">unicode</span>: <span style="color: #BA2121">u&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span> (<span style="color: #666666">10</span>)
</pre></div>
<p>
This time the unicode representation is as long as the expected number
of characters, and the special German  looks like <code>\xdf</code>.
In fact, this character has unicode representation
DF and we can use this code directly
when we define the string, instead of a German keyboard:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Gauss <span style="color: #666666">=</span> <span style="color: #BA2121">u&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(Gauss)
C<span style="color: #666666">.</span> F<span style="color: #666666">.</span> Gau, <span style="color: #008000">unicode</span>: <span style="color: #BA2121">u&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span> (<span style="color: #666666">10</span>)
</pre></div>
<p>
The string can be defined through the UTF-8 bytecode counterpart to ,
which is C3 9F:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Gauss <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xc3\x9f</span><span style="color: #BA2121">&#39;</span>  <span style="color: #408080; font-style: italic"># plain string</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(Gauss)
C<span style="color: #666666">.</span> F<span style="color: #666666">.</span> Gau, <span style="color: #008000">str</span>: <span style="color: #BA2121">&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xc3\x9f</span><span style="color: #BA2121">&#39;</span> (<span style="color: #666666">11</span>)
</pre></div>
<p>
Mixing UTF-8 bytecode in unicode strings, as in <code>u'C. F. Gau\xc3\x9f'</code>,
gives and unreadable output.

<p>
We can convert from a unicode representation to UTF-8 bytecode
and back again:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> Gauss <span style="color: #666666">=</span> <span style="color: #BA2121">u&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">repr</span>(Gauss<span style="color: #666666">.</span>encode(<span style="color: #BA2121">&#39;utf-8&#39;</span>))  <span style="color: #408080; font-style: italic"># convert to UTF-8 bytecode</span>
<span style="color: #BA2121">&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xc3\x9f</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">unicode</span>(Gauss<span style="color: #666666">.</span>encode(<span style="color: #BA2121">&#39;utf-8&#39;</span>), <span style="color: #BA2121">&#39;utf-8&#39;</span>)  <span style="color: #408080; font-style: italic"># convert back again</span>
<span style="color: #BA2121">u&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span>
</pre></div>
<p>
Other encodings are UTF-16 and latin-1:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">repr</span>(Gauss<span style="color: #666666">.</span>encode(<span style="color: #BA2121">&#39;utf-16&#39;</span>))
<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\xff\xfe</span><span style="color: #BA2121">C</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">.</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121"> </span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">F</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">.</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121"> </span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">G</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">a</span><span style="color: #BB6622; font-weight: bold">\x00</span><span style="color: #BA2121">u</span><span style="color: #BB6622; font-weight: bold">\x00\xdf\x00</span><span style="color: #BA2121">&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">repr</span>(Gauss<span style="color: #666666">.</span>encode(<span style="color: #BA2121">&#39;latin-1&#39;</span>))
<span style="color: #BA2121">&#39;C. F. Gau</span><span style="color: #BB6622; font-weight: bold">\xdf</span><span style="color: #BA2121">&#39;</span>
</pre></div>
<p>
Writing the unicode variable <code>Gauss</code> to file, a la <code>f.write(Gauss)</code>,
leads to a <code>UnicodeEncodeError</code> in Python 2, saying that <code>'ascii'
codec can't encode character u'\xdf' in position 9</code>.  The UTF-8
bytecode representation of strings does not pose any problems with
file writing.  The solution for unicode
strings is to use the <code>codecs</code> module and explicitly work with a
file object that converts unicode to UTF-8:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">codecs</span>
<span style="color: #008000; font-weight: bold">with</span> codecs<span style="color: #666666">.</span>open(<span style="color: #BA2121">&#39;tmp.txt&#39;</span>, <span style="color: #BA2121">&#39;w&#39;</span>, <span style="color: #BA2121">&#39;utf-8&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> f:
    f<span style="color: #666666">.</span>write(Gauss)
</pre></div>
<p>
This is not necessary with Python 3, so if you use non-English characters,
Python 3 has a clear advantage over Python 2.

<p>
To summarize, non-English character can be input with a non-English
keyboard and stored either as a plain (byte) string or as a unicode
string:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> name <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;smund degrd&#39;</span>  <span style="color: #408080; font-style: italic"># plain string</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(name)
smund degrd, <span style="color: #008000">str</span>: <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\xc3\x85</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xc3\x98</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xc3\xa5</span><span style="color: #BA2121">rd&#39;</span> (<span style="color: #666666">17</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> name <span style="color: #666666">=</span> <span style="color: #BA2121">u&#39;smund degrd&#39;</span> <span style="color: #408080; font-style: italic"># unicode</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(name)
smund degrd, <span style="color: #008000">unicode</span>: <span style="color: #BA2121">u&#39;</span><span style="color: #BB6622; font-weight: bold">\xc5</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xd8</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xe5</span><span style="color: #BA2121">rd&#39;</span> (<span style="color: #666666">14</span>)
</pre></div>
<p>
Alternatively, the non-English characters can be specified
with special codes, depending on whether the representation is a
plain UTF-8 string or a unicode string.
Using a <a href="http://www.utf8-chartable.de/" target="_self">table</a> with conversion
between unicode and UTF-8 representation we find that
in UTF-8,  has the code C3 85,  is C3 98, and  is C3 A5:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> name <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\xc3\x85</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xc3\x98</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xc3\xa5</span><span style="color: #BA2121">rd&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(name)
smund degrd, <span style="color: #008000">str</span>: <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\xc3\x85</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xc3\x98</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xc3\xa5</span><span style="color: #BA2121">rd&#39;</span> (<span style="color: #666666">17</span>)
</pre></div>
<p>
In unicode,  is C5,  is D8,  is E5:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> name <span style="color: #666666">=</span> <span style="color: #BA2121">u&#39;</span><span style="color: #BB6622; font-weight: bold">\xc5</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xd8</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xe5</span><span style="color: #BA2121">rd&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> check(name)
smund degrd, <span style="color: #008000">unicode</span>: <span style="color: #BA2121">u&#39;</span><span style="color: #BB6622; font-weight: bold">\xc5</span><span style="color: #BA2121">smund </span><span style="color: #BB6622; font-weight: bold">\xd8</span><span style="color: #BA2121">deg</span><span style="color: #BB6622; font-weight: bold">\xe5</span><span style="color: #BA2121">rd&#39;</span> (<span style="color: #666666">14</span>)
</pre></div>
<p>
The examples above have been collected in the file <a href="http://tinyurl.com/pwyasaa/files/unicode_utf8.py" target="_self"><tt>unicode_utf8.py</tt></a>.

<h1 id="sec:files:csv">Reading and writing spreadsheet files<a name="sec:files:csv"></a></h1>

From school you are probably used to spreadsheet programs such as
Microsoft Excel or LibreOffice. This type of program is used to represent
a table of numbers and text. Each table entry is known as a <em>cell</em>,
and one can easily perform calculations with cells that contain numbers.
The application of spreadsheet programs for mathematical computations
and graphics is steadily growing.

<p>
Also Python may be used to do spreadsheet-type calculations on tabular
data.  The advantage of using Python is that you can easily extend the
calculations far beyond what a spreadsheet program can do. However,
even if you can view Python as a substitute for a spreadsheet program,
it may be beneficial to combine the two. Suppose you have some data in
a spreadsheet. How can you read these data into a Python program,
perform calculations on the data, and thereafter read the data back to
the spreadsheet program? This is exactly what we will explain below
through an example. With this example, you should understand how easy
it is to combine Excel or LibreOffice with your own Python programs.

<h2 id="___sec47">CSV files <a name="___sec47"></a></h2>

The table of data in a spreadsheet can be saved in so-called CSV files,
where CSV stands for <em>comma separated values</em>.
The CSV file format is very simple:
each row in the spreadsheet table is a line in the file, and each cell
in the row is separated by a comma or some other specified
separation character.
CSV files can easily be read into Python programs, and the
table of
cell data can be stored in a nested list
(table, see the section ref{sec:basic:nestedlists}),
which can be processed as we desire.
The modified table of cell data can be written back to a CSV file and read into
the spreadsheet program for further processing.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  A simple spreadsheet in LibreOffice. <a name="sec:io:fig1"></a> </p></center>
<p><img src="fig-files/spreadsheet1.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#sec:io:fig1">5</a> shows a simple
spreadsheet in the LibreOffice program. The table contains \( 4\times 4 \)
cells, where the first row contains column headings and the first column contains
row headings. The remaining \( 3\times 3 \) subtable contains numbers that
we may compute with.
Let us save this spreadsheet to a file in the CSV format.
The complete file will typically look as follows:

<p>

<!-- code=text (!bc txt) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">,&quot;year 1&quot;,&quot;year 2&quot;,&quot;year 3&quot;
&quot;person 1&quot;,651000,651000,651000
&quot;person 2&quot;,1100500,950100,340000
&quot;person 3&quot;,740000,780000,800000
</pre></div>
<p>
Our primary task is now to load these data into a Python program,
compute the sum of each column, and write the data out again in the
CSV format.

<h2 id="___sec48">Reading CSV files <a name="___sec48"></a></h2>

We start with loading the data into a table, represented as
a nested list, with aid of the
<code>csv</code> module from Python's standard library.
This approach gives us complete control of all
details. Later, we will use more high-level <code>numpy</code> functionality
for accomplishing the same thing with less lines.

<p>
The <code>csv</code> module offers functionality for reading one line at a time
from a CSV file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;budget.csv&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)  <span style="color: #408080; font-style: italic"># CSV file</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">csv</span>
table <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> csv<span style="color: #666666">.</span>reader(infile):
    table<span style="color: #666666">.</span>append(row)
infile<span style="color: #666666">.</span>close()
</pre></div>
<p>
The <code>row</code> variable is a list of column values that are
read from the file by the <code>csv</code> module.
The three lines computing <code>table</code> can be condensed to one using
a list comprehension:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">table <span style="color: #666666">=</span> [row <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> csv<span style="color: #666666">.</span>reader(infile)]
</pre></div>
<p>
We can easily print <code>table</code>,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pprint</span>
pprint<span style="color: #666666">.</span>pprint(table)
</pre></div>
<p>
to see what the spreadsheet looks like
when it is represented as a nested list in a Python program:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[&#39;&#39;, &#39;year 1&#39;, &#39;year 2&#39;, &#39;year 3&#39;],
 [&#39;person 1&#39;, &#39;651000&#39;, &#39;651000&#39;, &#39;651000&#39;],
 [&#39;person 2&#39;, &#39;1100500&#39;, &#39;950100&#39;, &#39;340000&#39;],
 [&#39;person 3&#39;, &#39;740000&#39;, &#39;780000&#39;, &#39;800000&#39;]]
</pre></div>
</blockquote><p>
Observe now that all entries are surrounded by quotes, which means that
all entries are string (<code>str</code>) objects. This is a general rule:
the <code>csv</code> module reads all cells into string objects.
To compute with the numbers, we need to transform the string objects
to <code>float</code> objects. The transformation
should not be applied to the first row and first column, since the
cells here hold text.
The transformation from strings to numbers
therefore applies to the indices <code>r</code> and <code>c</code>
in <code>table</code> (<code>table[r][c]</code>), such that the row counter
<code>r</code> goes from 1 to <code>len(table)-1</code>,
and the column counter <code>c</code>
goes from 1 to <code>len(table[0])-1</code> (<code>len(table[0])</code> is
the length of the first row, assuming the lengths of all rows are
equal to the length of the first row).
The relevant Python code for this transformation task becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"> <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,<span style="color: #008000">len</span>(table)):
    <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(table[<span style="color: #666666">0</span>])):
        table[r][c] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(table[r][c])
</pre></div>
<p>
A <code>pprint.pprint(table)</code> statement after this transformation yields

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[&#39;&#39;, &#39;year 1&#39;, &#39;year 2&#39;, &#39;year 3&#39;],
 [&#39;person 1&#39;, 651000.0, 651000.0, 651000.0],
 [&#39;person 2&#39;, 1100500.0, 950100.0, 340000.0],
 [&#39;person 3&#39;, 740000.0, 780000.0, 800000.0]]
</pre></div>
</blockquote><p>
The numbers now have a decimal and no quotes, indicating
that the numbers are <code>float</code> objects and hence ready for mathematical
calculations.

<h2 id="___sec49">Processing spreadsheet data <a name="___sec49"></a></h2>

Let us perform a very simple calculation with <code>table</code>,
namely adding a final row
with the sum of the numbers in the columns:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">row <span style="color: #666666">=</span> [<span style="color: #666666">0.0</span>]<span style="color: #666666">*</span><span style="color: #008000">len</span>(table[<span style="color: #666666">0</span>])
row[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;sum&#39;</span>
<span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(row)):
    s <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(table)):
        s <span style="color: #666666">+=</span> table[r][c]
    row[c] <span style="color: #666666">=</span> s
</pre></div>
<p>
As seen, we first create a list <code>row</code> consisting of zeros.
Then we insert a text in the first column, before we invoke a
loop over the numbers in the table and compute the sum of each column.
The <code>table</code> list now represents a spreadsheet with four columns and
five rows:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[&#39;&#39;, &#39;year 1&#39;, &#39;year 2&#39;, &#39;year 3&#39;],
 [&#39;person 1&#39;, 651000.0, 651000.0, 651000.0],
 [&#39;person 2&#39;, 1100500.0, 950100.0, 340000.0],
 [&#39;person 3&#39;, 740000.0, 780000.0, 800000.0],
 [&#39;sum&#39;, 2491500.0, 2381100.0, 1791000.0]]
</pre></div>
</blockquote><h2 id="___sec50">Writing CSV files <a name="___sec50"></a></h2>

Our final task is to write the modified <code>table</code> list
back to a CSV file so that the data can be loaded in a spreadsheet program.
The write task is done by the code segment

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;budget2.csv&#39;</span>, <span style="color: #BA2121">&#39;w&#39;</span>)
writer <span style="color: #666666">=</span> csv<span style="color: #666666">.</span>writer(outfile)
<span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> table:
    writer<span style="color: #666666">.</span>writerow(row)
outfile<span style="color: #666666">.</span>close()
</pre></div>
<p>
The <code>budget2.csv</code> looks like this:

<p>

<!-- code=text (!bc txt) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">year 1,year 2,year 3
person 1,651000.0,651000.0,651000.0
person 2,1100500.0,950100.0,340000.0
person 3,740000.0,780000.0,800000.0
sum,2491500.0,2381100.0,1791000.0
</pre></div>
<p>
The final step is to read <code>budget2.csv</code> into a spreadsheet.
The result is displayed in Figure <a href="#sec:io:fig2">6</a>
(in LibreOffice one must specify in the <em>Open</em> dialog that
the spreadsheet data are separated by commas, i.e., that the file
is in CSV format).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  A spreadsheet processed in a Python program and loaded back into LibreOffice. <a name="sec:io:fig2"></a> </p></center>
<p><img src="fig-files/spreadsheet2.png" align="bottom" width=400></p>
</center>

<p>
The complete program reading the <code>budget.csv</code> file, processing its
data, and writing the <code>budget2.csv</code> file can be found in
<a href="http://tinyurl.com/pwyasaa/files/rw_csw.py" target="_self"><tt>rw_csv.py</tt></a>.  With this example at
hand, you should be in a good position to combine spreadsheet programs
with your own Python programs.

<h3 id="___sec51">Remark <a name="___sec51"></a></h3>

You may wonder why we used the <code>csv</code> module to read and write CSV
files when such files have comma separated values, which we can
extract by splitting lines with respect to the comma (this technique
is used in the section <a href="#sec:files:stockprices">Example: Reading and plotting data recorded at specific dates</a> to read a CSV file):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;budget.csv&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
<span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
    row <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;,&#39;</span>)
</pre></div>
<p>
This works well for the present <code>budget.csv</code> file, but the technique
breaks down when a text in a cell contains a comma, for instance
<code>"Aug 8, 2007"</code>. The <code>line.split(',')</code> will split this cell text, while
the <code>csv.reader</code> functionality is smart enough to avoid splitting
text cells with a comma.

<h2 id="___sec52">Representing number cells with Numerical Python arrays <a name="___sec52"></a></h2>

Instead of putting the whole spreadsheet into a single nested list,
we can make a Python data structure more tailored to the data at hand.
What we have are two headers (for rows and columns, respectively) and
a subtable of numbers. The headers can be represented as lists of strings,
while the subtable could be a two-dimensional Numerical Python array.
The latter makes it easier to implement various mathematical operations
on the numbers. A dictionary can hold all the three items: two header
lists and one array. The relevant code for reading, processing, and
writing the data is shown below and can be found in the file
<a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy.py" target="_self"><tt>rw_csv_numpy.py</tt></a>:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;budget.csv&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">csv</span>
table <span style="color: #666666">=</span> [row <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> csv<span style="color: #666666">.</span>reader(infile)]
infile<span style="color: #666666">.</span>close()

<span style="color: #408080; font-style: italic"># Convert subtable of numbers (string to float)</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span>
subtable <span style="color: #666666">=</span> [[<span style="color: #008000">float</span>(c) <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> row[<span style="color: #666666">1</span>:]] <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> table[<span style="color: #666666">1</span>:]]

data <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;column headings&#39;</span>: table[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>:],
        <span style="color: #BA2121">&#39;row headings&#39;</span>: [row[<span style="color: #666666">0</span>] <span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> table[<span style="color: #666666">1</span>:]],
        <span style="color: #BA2121">&#39;array&#39;</span>: numpy<span style="color: #666666">.</span>array(subtable)}

<span style="color: #408080; font-style: italic"># Add a new row with sums</span>
data[<span style="color: #BA2121">&#39;row headings&#39;</span>]<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;sum&#39;</span>)
a <span style="color: #666666">=</span> data[<span style="color: #BA2121">&#39;array&#39;</span>]   <span style="color: #408080; font-style: italic"># short form</span>
data[<span style="color: #BA2121">&#39;column sum&#39;</span>] <span style="color: #666666">=</span> [<span style="color: #008000">sum</span>(a[:,c]) <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(a<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>])]

outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;budget2.csv&#39;</span>, <span style="color: #BA2121">&#39;w&#39;</span>)
writer <span style="color: #666666">=</span> csv<span style="color: #666666">.</span>writer(outfile)
<span style="color: #408080; font-style: italic"># Turn data dictionary into a nested list first (for easy writing)</span>
table <span style="color: #666666">=</span> a<span style="color: #666666">.</span>tolist()   <span style="color: #408080; font-style: italic"># transform array to nested list</span>
table<span style="color: #666666">.</span>append(data[<span style="color: #BA2121">&#39;column sum&#39;</span>])
table<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, data[<span style="color: #BA2121">&#39;column headings&#39;</span>])
<span style="color: #408080; font-style: italic"># Extend table with row headings (a new column)</span>
[table[r<span style="color: #666666">+1</span>]<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, data[<span style="color: #BA2121">&#39;row headings&#39;</span>][r])
 <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(table)<span style="color: #666666">-1</span>)]
<span style="color: #008000; font-weight: bold">for</span> row <span style="color: #AA22FF; font-weight: bold">in</span> table:
    writer<span style="color: #666666">.</span>writerow(row)
outfile<span style="color: #666666">.</span>close()
</pre></div>
<p>
The code makes heavy use of list comprehensions, and the
transformation between a nested list, for file reading and writing,
and the <code>data</code> dictionary, for representing the data in the
Python program, is non-trivial. If you manage to understand every
line in this program, you have digested a lot of topics in
Python programming!

<h2 id="___sec53">Using more high-level Numerical Python functionality <a name="___sec53"></a></h2>

The previous program can be shortened significantly by applying
the <code>genfromtxt</code> function from Numerical Python:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
arr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>genfromtxt(<span style="color: #BA2121">&#39;budget.csv&#39;</span>, delimiter<span style="color: #666666">=</span><span style="color: #BA2121">&#39;,&#39;</span>, dtype<span style="color: #666666">=</span><span style="color: #008000">str</span>)

data <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;column headings&#39;</span>: arr[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>:]<span style="color: #666666">.</span>tolist(),
        <span style="color: #BA2121">&#39;row headings&#39;</span>: arr[<span style="color: #666666">1</span>:,<span style="color: #666666">0</span>]<span style="color: #666666">.</span>tolist(),
        <span style="color: #BA2121">&#39;array&#39;</span>: np<span style="color: #666666">.</span>asarray(arr[<span style="color: #666666">1</span>:,<span style="color: #666666">1</span>:], dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>float)}

data[<span style="color: #BA2121">&#39;row headings&#39;</span>]<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;sum&#39;</span>)
data[<span style="color: #BA2121">&#39;column sum&#39;</span>] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(data[<span style="color: #BA2121">&#39;array&#39;</span>], axis<span style="color: #666666">=1</span>)<span style="color: #666666">.</span>tolist()
</pre></div>
<p>
Doing a <code>repr(arr)</code> on the array returned from <code>genfromtxt</code>
results in

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">array([[&#39;&#39;, &#39;&quot;year 1&quot;&#39;, &#39;&quot;year 2&quot;&#39;, &#39;&quot;year 3&quot;&#39;],
       [&#39;&quot;person 1&quot;&#39;, &#39;651000&#39;, &#39;651000&#39;, &#39;651000&#39;],
       [&#39;&quot;person 2&quot;&#39;, &#39;1100500&#39;, &#39;950100&#39;, &#39;340000&#39;],
       [&#39;&quot;person 3&quot;&#39;, &#39;740000&#39;, &#39;780000&#39;, &#39;800000&#39;]],
      dtype=&#39;|S10&#39;)
</pre></div>
<p>
That is, the data in the CSV file are available as an array of
strings.  The code shows how we can easily use slices to extract the
row and column headings, convert the numbers to a floating-point array
for computations, compute the sums, and store various object in the
<code>data</code> dictionary. Then we may write a CSV file as described in the
previous example (see <a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy2.py" target="_self"><tt>rw_csv_numpy2.py</tt></a>) or we may take a different
approach and extend the <code>arr</code> array with an extra row and fill in the
row heading and the sums (see <a href="http://tinyurl.com/pwyasaa/files/rw_csv_numpy3.py" target="_self"><tt>rw_csv_numpy3.py</tt></a> for the complete code):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">arr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>genfromtxt(<span style="color: #BA2121">&#39;budget.csv&#39;</span>, delimiter<span style="color: #666666">=</span><span style="color: #BA2121">&#39;,&#39;</span>, dtype<span style="color: #666666">=</span><span style="color: #008000">str</span>)

<span style="color: #408080; font-style: italic"># Add row for sum of columns</span>
arr<span style="color: #666666">.</span>resize((arr<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]<span style="color: #666666">+1</span>, arr<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]))
arr[<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&quot;sum&quot;&#39;</span>
subtable <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(arr[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:], dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>float)
sum_row <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(subtable, axis<span style="color: #666666">=1</span>)
arr[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(sum_row, dtype<span style="color: #666666">=</span><span style="color: #008000">str</span>)

<span style="color: #408080; font-style: italic"># numpy.savetxt writes table with a delimiter between entires</span>
np<span style="color: #666666">.</span>savetxt(<span style="color: #BA2121">&#39;budget2c.csv&#39;</span>, arr, delimiter<span style="color: #666666">=</span><span style="color: #BA2121">&#39;,&#39;</span>, fmt<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span>)
</pre></div>
<p>
Observe how we extract the numbers in <code>subtable</code>, compute with them,
and put the results back into the <code>arr</code> array as strings. The
<code>savetxt</code> function saves a two-dimensional array as a plain table in
a text file, here with
comma as delimiter. The function suffices in this example, none of
the approaches with <code>genfromtxt</code> and <code>savetxt</code> work with
column or row headings containing a comma. Then we need to use the
<code>csv</code> module.

<h1 id="bioinf:DNAanalysis">Examples from analyzing DNA<a name="bioinf:DNAanalysis"></a></h1>

We shall here continue the bioinformatics applications started
in the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and branching</a> <a href="#Langtangen_TCSE6_funcif">[1]</a>. Analysis of DNA sequences is
conveniently done in Python, much with the aid of lists, dictionaries,
<code>numpy</code> arrays, strings, and files. This will be illustrated
through a series of examples.

<h2 id="bioinf:freqm">Computing frequencies<a name="bioinf:freqm"></a></h2>

Your genetic code is essentially the same from you are born until you
die, and the same in your blood and your brain.  Which genes that are
turned on and off make the difference between the cells. This
regulation of genes is orchestrated by an immensely complex mechanism,
which we have only started to understand. A central part of this
mechanism consists of molecules called transcription factors that
float around in the cell and attach to DNA, and in doing so turn
nearby genes on or off. These molecules bind preferentially to
specific DNA sequences, and this binding preference pattern can be
represented by a table of frequencies of given symbols at each
position of the pattern.  More precisely, each row in the table
corresponds to the bases A, C, G, and T, while column j reflects how
many times the base appears in position j in the DNA sequence.

<p>
For example, if our set of DNA sequences are
TAG, GGT, and GGG, the table becomes

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>base</b></td> <td align="center"><b> 0  </b></td> <td align="center"><b> 1  </b></td> <td align="center"><b> 2  </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   A       </td> <td align="center">   0       </td> <td align="center">   1       </td> <td align="center">   0       </td> </tr>
<tr><td align="left">   C       </td> <td align="center">   0       </td> <td align="center">   0       </td> <td align="center">   0       </td> </tr>
<tr><td align="left">   G       </td> <td align="center">   2       </td> <td align="center">   2       </td> <td align="center">   2       </td> </tr>
<tr><td align="left">   T       </td> <td align="center">   1       </td> <td align="center">   0       </td> <td align="center">   1       </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-5 -->
<p>
From this table we can read that base A appears once in index 1 in the
DNA strings, base C does not appear at all, base G appears twice in
all positions, and base T appears once in the beginning and end of the
strings.

<p>
In the following we shall present different data structures to
hold such a table and different ways of computing them.
The table is known as a <em>frequency matrix</em> in bioinformatics
and this is the term used here too.

<h3 id="___sec56">Separate frequency lists <a name="___sec56"></a></h3>

Since we know that there are only four rows in the frequency matrix,
an obvious data structure would be four lists, each holding
a row. A function computing these lists may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_lists</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(dna_list[<span style="color: #666666">0</span>])
    A <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n
    T <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n
    G <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n
    C <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            <span style="color: #008000; font-weight: bold">if</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;A&#39;</span>:
                A[index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;C&#39;</span>:
                C[index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;G&#39;</span>:
                G[index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;T&#39;</span>:
                T[index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> A, C, G, T
</pre></div>
<p>
We need to initialize the lists with the right length and a zero
for each element, since each list element is to be used as a counter.
Creating a list of length <code>n</code> with object <code>x</code> in all positions
is done by <code>[x]*n</code>. Finding the proper length is here carried out by
inspecting the length of the first element in <code>dna_list</code>, the list of
all DNA strings to be counted, assuming
that all elements in this list have the same length.

<p>
In the <code>for</code> loop we apply the <code>enumerate</code> function, which is used
to extract both the element value <em>and</em> the element index when
iterating over a sequence. For example,
<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>([<span style="color: #BA2121">&#39;t&#39;</span>, <span style="color: #BA2121">&#39;e&#39;</span>, <span style="color: #BA2121">&#39;s&#39;</span>, <span style="color: #BA2121">&#39;t&#39;</span>]):
<span style="color: #666666">...</span>   <span style="color: #008000; font-weight: bold">print</span> index, base
<span style="color: #666666">...</span>
<span style="color: #666666">0</span> t
<span style="color: #666666">1</span> e
<span style="color: #666666">2</span> s
<span style="color: #666666">3</span> t
</pre></div>
<p>
Here is a test,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dna_list <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;GGTAG&#39;</span>, <span style="color: #BA2121">&#39;GGTAC&#39;</span>, <span style="color: #BA2121">&#39;GGTGC&#39;</span>]
A, C, G, T <span style="color: #666666">=</span> freq_lists(dna_list)
<span style="color: #008000; font-weight: bold">print</span> A
<span style="color: #008000; font-weight: bold">print</span> C
<span style="color: #008000; font-weight: bold">print</span> G
<span style="color: #008000; font-weight: bold">print</span> T
</pre></div>
<p>
with output
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[0, 0, 0, 2, 0]
[0, 0, 0, 0, 2]
[3, 3, 0, 1, 1]
[0, 0, 3, 0, 0]
</pre></div>

<h3 id="___sec57">Nested list <a name="___sec57"></a></h3>

The frequency matrix can also be represented as a nested list <code>M</code>
such that <code>M[i][j]</code> is the frequency of base <code>i</code> in position <code>j</code>
in the set of DNA strings. Here <code>i</code> is an integer, where 0 corresponds to A,
1 to T, 2 to G, and 3 to C. The frequency is the number of times
base <code>i</code> appears in position <code>j</code> in a set of DNA strings.
Sometimes this number is divided by the number of DNA strings in
the set so that the frequency is between 0 and 1. Note that all
the DNA strings must have the same length.

<p>
The simplest way to make a nested list is to insert the
<code>A</code>, <code>C</code>, <code>G</code>, and <code>T</code> lists into another list:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> frequency_matrix <span style="color: #666666">=</span> [A, C, G, T]
<span style="color: #666666">&gt;&gt;&gt;</span> frequency_matrix[<span style="color: #666666">2</span>][<span style="color: #666666">3</span>]
<span style="color: #666666">2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> G[<span style="color: #666666">3</span>]  <span style="color: #408080; font-style: italic"># same element</span>
<span style="color: #666666">2</span>
</pre></div>
<p>
Alternatively, we can illustrate how to compute this type of nested
list directly:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_list_of_lists_v1</span>(dna_list):
    <span style="color: #408080; font-style: italic"># Create empty frequency_matrix[i][j] = 0</span>
    <span style="color: #408080; font-style: italic"># i=0,1,2,3 corresponds to A,T,G,C</span>
    <span style="color: #408080; font-style: italic"># j=0,...,length of dna_list[0]</span>
    frequency_matrix <span style="color: #666666">=</span> [[<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> dna_list[<span style="color: #666666">0</span>]] <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>]

    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
      <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
          <span style="color: #008000; font-weight: bold">if</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;A&#39;</span>:
              frequency_matrix[<span style="color: #666666">0</span>][index] <span style="color: #666666">+=1</span>
          <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;C&#39;</span>:
              frequency_matrix[<span style="color: #666666">1</span>][index] <span style="color: #666666">+=1</span>
          <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;G&#39;</span>:
              frequency_matrix[<span style="color: #666666">2</span>][index] <span style="color: #666666">+=1</span>
          <span style="color: #008000; font-weight: bold">elif</span> base <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;T&#39;</span>:
              frequency_matrix[<span style="color: #666666">3</span>][index] <span style="color: #666666">+=1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
As in the case with individual lists we need to initialize all elements
in the nested list to zero.

<p>
A call and printout,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dna_list <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;GGTAG&#39;</span>, <span style="color: #BA2121">&#39;GGTAC&#39;</span>, <span style="color: #BA2121">&#39;GGTGC&#39;</span>]
frequency_matrix <span style="color: #666666">=</span> freq_list_of_lists_v1(dna_list)
<span style="color: #008000; font-weight: bold">print</span> frequency_matrix
</pre></div>
<p>
results in
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[0, 0, 0, 2, 0], [0, 0, 0, 0, 2], [3, 3, 0, 1, 1], [0, 0, 3, 0, 0]]
</pre></div>

<h3 id="___sec58">Dictionary for more convenient indexing <a name="___sec58"></a></h3>

The series of <code>if</code> tests in the Python function <code>freq_list_of_lists_v1</code>
are somewhat cumbersome,
especially if we want to extend the code to other bioinformatics problems
where the alphabet is larger. What we want is a mapping from <code>base</code>,
which is a character, to the corresponding index 0, 1, 2, or 3.
A Python dictionary may represent such mappings:
<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> base2index <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">3</span>}
<span style="color: #666666">&gt;&gt;&gt;</span> base2index[<span style="color: #BA2121">&#39;G&#39;</span>]
<span style="color: #666666">2</span>
</pre></div>
<p>
With the <code>base2index</code> dictionary we do not need the series of
<code>if</code> tests and the alphabet <code>'ATGC'</code> could be much larger
without affecting the length of the code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_list_of_lists_v2</span>(dna_list):
    frequency_matrix <span style="color: #666666">=</span> [[<span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> dna_list[<span style="color: #666666">0</span>]] <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>]
    base2index <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">3</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base2index[base]][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>

<h3 id="___sec59">Numerical Python array <a name="___sec59"></a></h3>

As long as each sublist in a list of lists has the same length, a
list of lists can be replaced by a Numerical Python (<code>numpy</code>) array.
Processing of such arrays is often much more efficient than
processing of the nested list data structure.
To initialize a two-dimensional <code>numpy</code> array we need to know its
size, here 4 times <code>len(dna_list[0])</code>. Only the first line in the function
<code>freq_list_of_lists_v2</code> needs to be changed in order to utilize
a <code>numpy</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_numpy</span>(dna_list):
    frequency_matrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #666666">4</span>, <span style="color: #008000">len</span>(dna_list[<span style="color: #666666">0</span>])), dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
    base2index <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">3</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base2index[base]][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
The resulting <code>frequency_matrix</code> object can be indexed as
<code>[b][i]</code> or <code>[b,i]</code>, with integers <code>b</code> and <code>i</code>. Typically, <code>b</code> will
be something line <code>base2index['C']</code>.

<h3 id="___sec60">Dictionary of lists <a name="___sec60"></a></h3>

Instead of going from a character to an integer index via
<code>base2index</code>, we may prefer to index <code>frequency_matrix</code> by the base name
and the position index directly, like in <code>['C'][14]</code>.
This is the most natural syntax for a user of the
frequency matrix.  The relevant Python data structure is then a
dictionary of lists. That is, <code>frequency_matrix</code> is a dictionary with
keys <code>'A'</code>, <code>'C'</code>, <code>'G'</code>, and <code>'T'</code>. The value for each key is a
list. Let us now also extend the flexibility such that <code>dna_list</code> can
have DNA strings of different lengths. The lists in <code>frequency_list</code>
will have lengths equal to the longest DNA string.  A relevant
function is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_lists_v1</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {
        <span style="color: #BA2121">&#39;A&#39;</span>: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n,
        <span style="color: #BA2121">&#39;C&#39;</span>: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n,
        <span style="color: #BA2121">&#39;G&#39;</span>: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n,
        <span style="color: #BA2121">&#39;T&#39;</span>: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n,
        }
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
Running the test code

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">frequency_matrix <span style="color: #666666">=</span> freq_dict_of_lists_v1(dna_list)
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pprint</span>   <span style="color: #408080; font-style: italic"># for nice printout of nested data structures</span>
pprint<span style="color: #666666">.</span>pprint(frequency_matrix)
</pre></div>
<p>
results in the output
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{&#39;A&#39;: [0, 0, 0, 2, 0],
 &#39;C&#39;: [0, 0, 0, 0, 2],
 &#39;G&#39;: [3, 3, 0, 1, 1],
 &#39;T&#39;: [0, 0, 3, 0, 0]}
</pre></div>
<p>
The initialization of <code>frequency_matrix</code> in the above code can
be made more compact by using a dictionary comprehension:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000">dict</span> <span style="color: #666666">=</span> {key: value <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> some_sequence}
</pre></div>
<p>
In our example we set
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">frequency_matrix <span style="color: #666666">=</span> {base: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
</pre></div>
<p>
Adopting this construction in the <code>freq_dict_of_lists_v1</code> function
leads to a slightly more compact version:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_lists_v2</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {base: [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>n <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
As an additional comment on computing the maximum length of the DNA
strings can be made as there are several alternative ways of doing
this.  The classical use of <code>max</code> is to apply it to a list as done
above:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
</pre></div>
<p>
However, for very long lists it is possible to avoid the memory demands
of storing the result of the list comprehension, i.e., the list of
lengths. Instead <code>max</code> can work with the lengths as they are computed:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> <span style="color: #008000">max</span>(<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list)
</pre></div>
<p>
It is also possible to write
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n <span style="color: #666666">=</span> <span style="color: #008000">max</span>(dna_list, key<span style="color: #666666">=</span><span style="color: #008000">len</span>)
</pre></div>
<p>
Here, <code>len</code> is applied to each element in <code>dna_list</code>, and the
maximum of the resulting values is returned.

<h3 id="___sec61">Dictionary of dictionaries <a name="___sec61"></a></h3>

The dictionary of lists data structure can alternatively be replaced
by a dictionary of dictionaries object, often just called a dict of
dicts object. That is, <code>frequency_matrix[base]</code> is a dictionary with
key <code>i</code> and value equal to the added number of occurrences of <code>base</code> in
<code>dna[i]</code> for all <code>dna</code> strings in the list <code>dna_list</code>.  The indexing
<code>frequency_matrix['C'][i]</code> and the values are exactly as in the last
example; the only difference is whether <code>frequency_matrix['C']</code> is a
list or dictionary.

<p>
Our function working with <code>frequency_matrix</code> as a dict of dicts
is written as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_dicts_v1</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {base: {index: <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">for</span> index <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)}
                        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>

<h3 id="___sec62">Using dictionaries with default values <a name="___sec62"></a></h3>

The manual initialization of each subdictionary to zero,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    frequency_matrix <span style="color: #666666">=</span> {base: {index: <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">for</span> index <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n)}
                        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
</pre></div>
<p>
can be simplified by using a dictionary with default values for any
key. The construction <code>defaultdict(lambda: obj)</code>
makes a dictionary with <code>obj</code> as default value.
This construction simplifies the previous function a bit:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">collections</span> <span style="color: #008000; font-weight: bold">import</span> defaultdict

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_dicts_v2</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {base: defaultdict(<span style="color: #008000; font-weight: bold">lambda</span>: <span style="color: #666666">0</span>)
                        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
<b>Remark.</b>
Dictionary comprehensions were new in Python 2.7 and 3.1, but can be
simulated in earlier versions by making (key, value) tuples via
list comprehensions. A dictionary comprehension
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">d <span style="color: #666666">=</span> {key: value <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> sequence}
</pre></div>
<p>
is then constructed as
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">d <span style="color: #666666">=</span> <span style="color: #008000">dict</span>([(key, value) <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> sequence])
</pre></div>

<h3 id="___sec63">Using arrays and vectorization <a name="___sec63"></a></h3>

The <code>frequency_matrix</code> dict of lists for can easily be
changed to a dict of <code>numpy</code> arrays: just replace the initialization
<code>[0]*n</code> by <code>np.zeros(n, dtype=np.int)</code>. The indexing remains the same:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_arrays_v1</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {base: np<span style="color: #666666">.</span>zeros(n, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
                        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        <span style="color: #008000; font-weight: bold">for</span> index, base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(dna):
            frequency_matrix[base][index] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
Having <code>frequency_matrix[base]</code> as a <code>numpy</code> array instead of a list
does not give any immediate advantage, as the storage and CPU time is
about the same. The loop over the <code>dna</code> string and the associated
indexing is what consumes all the CPU time.  However, the <code>numpy</code>
arrays provide a potential for increasing efficiency through
vectorization, i.e., replacing the element-wise operations on <code>dna</code>
and <code>frequency_matrix[base]</code> by operations on the entire arrays at
once.

<p>
Let us use the interactive Python shell to
explore the possibilities of vectorization.
We first convert the string to a <code>numpy</code> array of characters:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> dna <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ACAT&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dna <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(dna, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> dna
array([<span style="color: #BA2121">&#39;A&#39;</span>, <span style="color: #BA2121">&#39;C&#39;</span>, <span style="color: #BA2121">&#39;A&#39;</span>, <span style="color: #BA2121">&#39;T&#39;</span>],
      dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;|S1&#39;</span>)
</pre></div>
<p>
For a given base, say A, we can in one vectorized operation find
which locations in <code>dna</code> that contain <code>A</code>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> b <span style="color: #666666">=</span> dna <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;A&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> b
array([ <span style="color: #008000">True</span>, <span style="color: #008000">False</span>,  <span style="color: #008000">True</span>, <span style="color: #008000">False</span>], dtype<span style="color: #666666">=</span><span style="color: #008000">bool</span>)
</pre></div>
<p>
By converting <code>b</code> to an integer array <code>i</code> we can
update the frequency counts
for all indices by adding <code>i</code> to <code>frequency_matrix['A']</code>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> i <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(b, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
<span style="color: #666666">&gt;&gt;&gt;</span> i
array([<span style="color: #666666">1</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> frequency_matrix[<span style="color: #BA2121">&#39;A&#39;</span>] <span style="color: #666666">=</span> frequency_matrix[<span style="color: #BA2121">&#39;A&#39;</span>] <span style="color: #666666">+</span> i
</pre></div>
<p>
This recipe can be repeated for all bases:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        dna <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(dna, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>)
        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>:
            b <span style="color: #666666">=</span> dna <span style="color: #666666">==</span> base
            i <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(b, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
            frequency_matrix[base] <span style="color: #666666">=</span> frequency_matrix[base] <span style="color: #666666">+</span> i
</pre></div>
<p>
It turns out that we do not need to convert the boolean array <code>b</code>
to an integer array <code>i</code>, because doing arithmetics with <code>b</code> directly
is possible: <code>False</code> is interpreted as 0 and <code>True</code> as 1 in arithmetic
operations.  We can also use
the <code>+=</code> operator to update all elements of <code>frequency_matrix[base]</code>
directly, without first computing the sum of two arrays
<code>frequency_matrix[base] + i</code> and then assigning this result to
<code>frequency_matrix[base]</code>.
Collecting all these ideas in one function yields the code

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">freq_dict_of_arrays_v2</span>(dna_list):
    n <span style="color: #666666">=</span> <span style="color: #008000">max</span>([<span style="color: #008000">len</span>(dna) <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list])
    frequency_matrix <span style="color: #666666">=</span> {base: np<span style="color: #666666">.</span>zeros(n, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
                        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>}
    <span style="color: #008000; font-weight: bold">for</span> dna <span style="color: #AA22FF; font-weight: bold">in</span> dna_list:
        dna <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(dna, dtype<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>)
        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACCT&#39;</span>:
            frequency_matrix[base] <span style="color: #666666">+=</span> dna <span style="color: #666666">==</span> base

    <span style="color: #008000; font-weight: bold">return</span> frequency_matrix
</pre></div>
<p>
This vectorized function runs almost 10 times as fast as the
(scalar) counterpart <code>freq_list_of_arrays_v1</code>!

<p>
<!-- memory mapped files? -->

<h2 id="bioinf:freq:analysis">Analyzing the frequency matrix<a name="bioinf:freq:analysis"></a></h2>

Having built a frequency matrix out of a collection of DNA strings, it
is time to use it for analysis.
The short DNA strings that a frequency matrix is built out of, is
typically a set of substrings of a larger DNA sequence, which shares
some common purpose. An example of this is to have a set of substrings
that serves as a kind of anchors/magnets at which given molecules
attach to DNA and perform biological functions (like turning genes on
or off). With the frequency matrix constructed from a limited set of
known anchor locations (substrings), we can now scan for other similar
substrings that have the potential to perform the same function. The
simplest way to do this is to first determine the most typical
substring according to the frequency matrix, i.e., the substring having
the most frequent nucleotide at each position. This is referred to as
the consensus string of the frequency matrix. We can then look for
occurrences of the consensus substring in a larger DNA sequence, and
consider these occurrences as likely candidates for serving the same
function (e.g., as anchor locations for molecules).

<p>
For instance,
given three substrings ACT, CCA and AGA, the frequency matrix
would be (list of lists, with rows corresponding to A, C, G, and T):
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[2, 0, 2]
 [1, 2, 0]
 [0, 1, 0]
 [0, 0, 1]]
</pre></div>
<p>
We see that for position 0,
which corresponds to the left-most column in the table, the symbol A has the
highest frequency (2). The maximum frequencies for the other positions
are seen to be C for position 1, and A for position 2. The consensus
string is therefore ACA.  Note that the consensus string does not need to be
equal to any of the substrings that formed the basis of the frequency
matrix (this is indeed the case for the above example).

<h3 id="___sec65">List of lists frequency matrix <a name="___sec65"></a></h3>

Let <code>frequency_matrix</code> be a list of lists. For each position <code>i</code> we
run through the rows in the frequency matrix and keep track of the
maximum frequency value and the corresponding letter. If two or
more letters have the same frequency value we use a dash to
indicate that this position in the consensus string is undetermined.

<p>
The following function computes the consensus string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_consensus_v1</span>(frequency_matrix):
    base2index <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">3</span>}
    consensus <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    dna_length <span style="color: #666666">=</span> <span style="color: #008000">len</span>(frequency_matrix[<span style="color: #666666">0</span>])

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(dna_length):  <span style="color: #408080; font-style: italic"># loop over positions in string</span>
        max_freq <span style="color: #666666">=</span> <span style="color: #666666">-1</span>            <span style="color: #408080; font-style: italic"># holds the max freq. for this i</span>
        max_freq_base <span style="color: #666666">=</span> <span style="color: #008000">None</span>     <span style="color: #408080; font-style: italic"># holds the corresponding base</span>

        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ATGC&#39;</span>:
            <span style="color: #008000; font-weight: bold">if</span> frequency_matrix[base2index[base]][i] <span style="color: #666666">&gt;</span> max_freq:
                max_freq <span style="color: #666666">=</span> frequency_matrix[base2index[base]][i]
                max_freq_base <span style="color: #666666">=</span> base
            <span style="color: #008000; font-weight: bold">elif</span> frequency_matrix[base2index[base]][i] <span style="color: #666666">==</span> max_freq:
                max_freq_base <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;-&#39;</span> <span style="color: #408080; font-style: italic"># more than one base as max</span>

        consensus <span style="color: #666666">+=</span> max_freq_base  <span style="color: #408080; font-style: italic"># add new base with max freq</span>
    <span style="color: #008000; font-weight: bold">return</span> consensus
</pre></div>
<p>
Since this code requires <code>frequency_matrix</code> to be a list of lists
we should insert a test and raise an exception if the
type is wrong:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_consensus_v1</span>(frequency_matrix):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(frequency_matrix, <span style="color: #008000">list</span>) <span style="color: #AA22FF; font-weight: bold">and</span> \ 
       <span style="color: #008000">isinstance</span>(frequency_matrix[<span style="color: #666666">0</span>], <span style="color: #008000">list</span>):
        <span style="color: #008000; font-weight: bold">pass</span> <span style="color: #408080; font-style: italic"># right type</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">TypeError</span>(<span style="color: #BA2121">&#39;frequency_matrix must be list of lists&#39;</span>)
    <span style="color: #666666">...</span>
</pre></div>

<h3 id="___sec66">Dict of dicts frequency matrix <a name="___sec66"></a></h3>

How must the <code>find_consensus_v1</code> function be altered if <code>frequency_matrix</code>
is a dict of dicts?

<ol>
 <li> The <code>base2index</code> dict is no longer needed.</li>
 <li> Access of sublist, <code>frequency_matrix[0]</code>, to test for type and
    length of the strings, must be replaced
    by <code>frequency_matrix['A']</code>.</li>
</ol>

The updated function becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_consensus_v3</span>(frequency_matrix):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(frequency_matrix, <span style="color: #008000">dict</span>) <span style="color: #AA22FF; font-weight: bold">and</span> \ 
       <span style="color: #008000">isinstance</span>(frequency_matrix[<span style="color: #BA2121">&#39;A&#39;</span>], <span style="color: #008000">dict</span>):
        <span style="color: #008000; font-weight: bold">pass</span> <span style="color: #408080; font-style: italic"># right type</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">TypeError</span>(<span style="color: #BA2121">&#39;frequency_matrix must be dict of dicts&#39;</span>)

    consensus <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    dna_length <span style="color: #666666">=</span> <span style="color: #008000">len</span>(frequency_matrix[<span style="color: #BA2121">&#39;A&#39;</span>])

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(dna_length):  <span style="color: #408080; font-style: italic"># loop over positions in string</span>
        max_freq <span style="color: #666666">=</span> <span style="color: #666666">-1</span>            <span style="color: #408080; font-style: italic"># holds the max freq. for this i</span>
        max_freq_base <span style="color: #666666">=</span> <span style="color: #008000">None</span>     <span style="color: #408080; font-style: italic"># holds the corresponding base</span>

        <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ACGT&#39;</span>:
            <span style="color: #008000; font-weight: bold">if</span> frequency_matrix[base][i] <span style="color: #666666">&gt;</span> max_freq:
                max_freq <span style="color: #666666">=</span> frequency_matrix[base][i]
                max_freq_base <span style="color: #666666">=</span> base
            <span style="color: #008000; font-weight: bold">elif</span> frequency_matrix[base][i] <span style="color: #666666">==</span> max_freq:
                max_freq_base <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;-&#39;</span> <span style="color: #408080; font-style: italic"># more than one base as max</span>

        consensus <span style="color: #666666">+=</span> max_freq_base  <span style="color: #408080; font-style: italic"># add new base with max freq</span>
    <span style="color: #008000; font-weight: bold">return</span> consensus
</pre></div>
<p>
Here is a test:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">frequency_matrix <span style="color: #666666">=</span> freq_dict_of_dicts_v1(dna_list)
pprint<span style="color: #666666">.</span>pprint(frequency_matrix)
<span style="color: #008000; font-weight: bold">print</span> find_consensus_v3(frequency_matrix)
</pre></div>
<p>
with output
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{&#39;A&#39;: {0: 0, 1: 0, 2: 0, 3: 2, 4: 0},
 &#39;C&#39;: {0: 0, 1: 0, 2: 0, 3: 0, 4: 2},
 &#39;G&#39;: {0: 3, 1: 3, 2: 0, 3: 1, 4: 1},
 &#39;T&#39;: {0: 0, 1: 0, 2: 3, 3: 0, 4: 0}}
Consensus string: GGTAC
</pre></div>
<p>
Let us try <code>find_consensus_v3</code> with the dict of defaultdicts
as input (<code>freq_dicts_of_dicts_v2</code>). The code runs fine, but
the output string is just <code>G</code>!
The reason is that <code>dna_length</code> is 1, and therefore that the length of
the <code>A</code> dict in <code>frequency_matrix</code> is 1.
Printing out <code>frequency_matrix</code> yields
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{<span style="color: #BA2121">&#39;A&#39;</span>: defaultdict(X, {<span style="color: #666666">3</span>: <span style="color: #666666">2</span>}),
 <span style="color: #BA2121">&#39;C&#39;</span>: defaultdict(X, {<span style="color: #666666">4</span>: <span style="color: #666666">2</span>}),
 <span style="color: #BA2121">&#39;G&#39;</span>: defaultdict(X, {<span style="color: #666666">0</span>: <span style="color: #666666">3</span>, <span style="color: #666666">1</span>: <span style="color: #666666">3</span>, <span style="color: #666666">3</span>: <span style="color: #666666">1</span>, <span style="color: #666666">4</span>: <span style="color: #666666">1</span>}),
 <span style="color: #BA2121">&#39;T&#39;</span>: defaultdict(X, {<span style="color: #666666">2</span>: <span style="color: #666666">3</span>})}
</pre></div>
<p>
where our <code>X</code> is a short form for text like
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121">`&lt;function &lt;lambda&gt; at 0xfaede8&gt;`</span>
</pre></div>
<p>
We see that the length of a defaultdict will only count the nonzero
entries. Hence, to use a defaultdict our function must get the length of the DNA string to
build as an extra argument:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">find_consensus_v4</span>(frequency_matrix, dna_length):
    <span style="color: #666666">...</span>
</pre></div>
<p>
<a href="#bioinf:exer:freq:fargs">Exercise 16: Allow different types for a function argument</a> suggests to make a unified
<code>find_consensus</code> function which works with all of the different
representations of <code>frequency_matrix</code> that we have used.

<p>
The functions making and using the frequency matrix are found
in the file <a href="http://tinyurl.com/pwyasaa/files/freq.py" target="_self"><tt>freq.py</tt></a>.

<h2 id="bioinf:basefreq">Finding base frequencies<a name="bioinf:basefreq"></a></h2>

DNA consists of four molecules called nucleotides, or bases, and can
be represented as a string of the letters A, C, G, and T. But this
does not mean that all four nucleotides need to be similarly
frequent. Are some nucleotides more frequent than others, say in
yeast, as represented by the first chromosome of yeast? Also, DNA is
really not a single thread, but two threads wound together.  This
wounding is based on an A from one thread binding to a T of the other
thread, and C binding to G (that is, A will only bind with T, not with
C or G).  Could this fact force groups of the four symbol frequencies
to be equal?  The answer is that the A-T and G-C binding does not in principle
force certain frequencies to be equal, but in practice they usually
become so because of evolutionary factors related to this pairing.

<p>
Our first programming task now is to compute the frequencies of the
bases A, C, G, and T. That is, the number of times each base occurs in
the DNA string, divided by the length of the string.  For example, if
the DNA string is ACGGAAA, the length is 7, A appears 4 times with
frequency 4/7, C appears once with frequency 1/7, G appears twice with
frequency 2/7, and T does not appear so the frequency is 0.

<p>
From a coding perspective we may create a function for counting how
many times A, C, G, and T appears in the string and then another
function for computing the frequencies. In both cases we want
dictionaries such that we can index with the character and get the
count or the frequency out.
Counting is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_base_counts</span>(dna):
    counts <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">0</span>}
    <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> dna:
        counts[base] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> counts
</pre></div>
<p>
This function can then be used to compute the base frequencies:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_base_frequencies_v1</span>(dna):
    counts <span style="color: #666666">=</span> get_base_counts(dna)
    <span style="color: #008000; font-weight: bold">return</span> {base: count<span style="color: #666666">*1.0/</span><span style="color: #008000">len</span>(dna)
            <span style="color: #008000; font-weight: bold">for</span> base, count <span style="color: #AA22FF; font-weight: bold">in</span> counts<span style="color: #666666">.</span>items()}
</pre></div>
<p>
Since we learned at the end of the document <a href="http://tcse6.on.net/funcif" target="_self">Functions and branching</a> <a href="#Langtangen_TCSE6_funcif">[1]</a> that
<code>dna.count(base)</code> was much faster than the various manual
implementations of counting, we can write a faster and simpler
function for computing all the base frequencies:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_base_frequencies_v2</span>(dna):
        <span style="color: #008000; font-weight: bold">return</span> {base: dna<span style="color: #666666">.</span>count(base)<span style="color: #666666">/</span><span style="color: #008000">float</span>(<span style="color: #008000">len</span>(dna))
                <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;ATGC&#39;</span>}
</pre></div>
<p>
A little test,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dna <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;ACCAGAGT&#39;</span>
frequencies <span style="color: #666666">=</span> get_base_frequencies_v2(dna)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">format_frequencies</span>(frequencies):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (base, frequencies[base])
                      <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> frequencies])

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;Base frequencies of sequence &#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">%</span> \ 
      (dna, format_frequencies(frequencies))
</pre></div>
<p>
gives the result
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Base frequencies of sequence &#39;ACCAGAGT&#39;:
A: 0.38, C: 0.25, T: 0.12, G: 0.25
</pre></div>
<p>
The <code>format_frequencies</code> function was made for nice printout of
the frequencies with 2 decimals. The one-line code is an effective
combination of a dictionary, list comprehension, and the
<code>join</code> functionality. The latter is used to get a comma correctly
inserted between the items in the result. Lazy programmers would
probably just do a <code>print frequencies</code> and live with the
curly braces in the output and (in general) 16 disturbing decimals.

<p>
We can try the frequency computation on real data. The file
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://hplgit.github.com/bioinf-py/data/yeast_chr1.txt
</pre></div>
<p>
contains the DNA for yeast. We can download this file from
the Internet by
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span>name_of_local_file)
</pre></div>
<p>
where <code>url</code> is the Internet address of the file and <code>name_of_local_file</code>
is a string containing the name of the file on the computer where the
file is downloaded.
To avoid repeated downloads when the program is run multiple times,
we insert a test on whether the local file exists or not. The
call <code>os.path.isfile(f)</code> returns <code>True</code> if a file with name <code>f</code> exists
in the current working folder.

<p>
The appropriate download code then becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">urllib</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
urlbase <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
yeast_file <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;yeast_chr1.txt&#39;</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isfile(yeast_file):
    url <span style="color: #666666">=</span> urlbase <span style="color: #666666">+</span> yeast_file
    urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span>yeast_file)
</pre></div>
<p>
A copy of the file on the Internet is now in the current working folder
under the name <code>yeast_chr1.txt</code>.
(See the section <a href="#sec:files:urllib">How to access web pages in programs</a> for
more information about \emp{urllib} and downloading files from
the Internet.)

<p>
The <code>yeast_chr1.txt</code> files contains the DNA string split over many lines.
We therefore need to read the lines in this file, strip each line to
remove the trailing newline, and join all the stripped lines to
recover the DNA string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_dnafile_v1</span>(filename):
    lines <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)<span style="color: #666666">.</span>readlines()
    <span style="color: #408080; font-style: italic"># Remove newlines in each line (line.strip()) and join</span>
    dna <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span><span style="color: #666666">.</span>join([line<span style="color: #666666">.</span>strip() <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines])
    <span style="color: #008000; font-weight: bold">return</span> dna
</pre></div>
<p>
As usual, an alternative programming solution can be devised:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_dnafile_v2</span>(filename):
    dna <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>):
        dna <span style="color: #666666">+=</span> line<span style="color: #666666">.</span>strip()
    <span style="color: #008000; font-weight: bold">return</span> dna

dna <span style="color: #666666">=</span> read_dnafile_v2(yeast_file)
yeast_freq <span style="color: #666666">=</span> get_base_frequencies_v2(dna)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;Base frequencies of yeast DNA (length </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">):</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">%</span> \ 
      (<span style="color: #008000">len</span>(dna), format_frequencies(yeast_freq))
</pre></div>
<p>
The output becomes
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Base frequencies of yeast DNA (length 230208):
A: 0.30, C: 0.19, T: 0.30, G: 0.20
</pre></div>
<p>
The varying frequency of different nucleotides in DNA is referred to
as nucleotide bias. The nucleotide bias varies between organisms, and
have a range of biological implications. For many organisms the
nucleotide bias has been highly optimized through evolution and
reflects characteristics of the organisms and their environments, for
instance the typical temperature the organism is adapted to.

<p>
<!-- This shows that A and T appears in the yeast DNA with 50 percent higher -->
<!-- probability than C and G. -->

<p>
The functions computing base frequencies are available
in the file <a href="http://tinyurl.com/pwyasaa/files/basefreq.py" target="_self"><tt>basefreq.py</tt></a>.

<h2 id="bioinf:gene2protein">Translating genes into proteins<a name="bioinf:gene2protein"></a></h2>

An important usage of DNA is for cells to store information on their
arsenal of proteins. Briefly, a gene is, in essence, a region of the
DNA, consisting of several coding parts (called exons), interspersed
by non-coding parts (called introns).  The coding parts are
concatenated to form a string called mRNA, where also occurrences of
the letter T in the coding parts are substituted by a U. A triplet of
mRNA letters code for a specific amino acid, which are the building
blocks of proteins. Consecutive triplets of letters in mRNA define a
specific sequence of amino acids, which amounts to a certain protein.

<p>
Here is an example of using the mapping from DNA to proteins to create
the Lactase protein (LPH), using the DNA sequence of the Lactase gene
(LCT) as underlying code. An important functional property of LPH is
in digesting Lactose, which is found most notably in milk. Lack of the
functionality of LPH leads to digestive problems referred to as
lactose intolerance. Most mammals and humans lose their expression of
LCT and therefore their ability to digest milk when they stop
receiving breast milk.

<p>
The file
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">http://hplgit.github.com/bioinf-py/doc/src/data/genetic_code.tsv
</pre></div>
<p>
contains a mapping of genetic codes to amino acids.
The file format looks like
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">UUU     F       Phe     Phenylalanine
UUC     F       Phe     Phenylalanine
UUA     L       Leu     Leucine
UUG     L       Leu     Leucine
CUU     L       Leu     Leucine
CUC     L       Leu     Leucine
CUA     L       Leu     Leucine
CUG     L       Leu     Leucine
AUU     I       Ile     Isoleucine
AUC     I       Ile     Isoleucine
AUA     I       Ile     Isoleucine
AUG     M       Met     Methionine (Start)
</pre></div>
<p>
The first column is the genetic code (triplet in mRNA),
while the other columns represent
various ways of expressing the corresponding amino acid:
a 1-letter symbol, a 3-letter name, and the full name.

<p>
Downloading the <code>genetic_code.tsv</code> file can be done by
this robust function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">download</span>(urlbase, filename):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isfile(filename):
        url <span style="color: #666666">=</span> urlbase <span style="color: #666666">+</span> filename
        <span style="color: #008000; font-weight: bold">try</span>:
            urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span>filename)
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #D2413A; font-weight: bold">IOError</span> <span style="color: #008000; font-weight: bold">as</span> e:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">IOError</span>(<span style="color: #BA2121">&#39;No Internet connection&#39;</span>)
        <span style="color: #408080; font-style: italic"># Check if downloaded file is an HTML file, which</span>
        <span style="color: #408080; font-style: italic"># is what github.com returns if the URL is not existing</span>
        f <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;DOCTYPE html&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> f<span style="color: #666666">.</span>readline():
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">IOError</span>(<span style="color: #BA2121">&#39;URL </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> does not exist&#39;</span> <span style="color: #666666">%</span> url)
</pre></div>
<p>
We want to make a dictionary of this file that maps the code (first
column) on to the 1-letter name (second column):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_genetic_code_v1</span>(filename):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    genetic_code <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        columns <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        genetic_code[columns[<span style="color: #666666">0</span>]] <span style="color: #666666">=</span> columns[<span style="color: #666666">1</span>]
    <span style="color: #008000; font-weight: bold">return</span> genetic_code
</pre></div>
<p>
Downloading the file, reading it, and making the dictionary are done
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">urlbase <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;http://hplgit.github.com/bioinf-py/data/&#39;</span>
genetic_code_file <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;genetic_code.tsv&#39;</span>
download(urlbase, genetic_code_file)
code <span style="color: #666666">=</span> read_genetic_code_v1(genetic_code_file)
</pre></div>
<p>
Not surprisingly, the <code>read_genetic_code_v1</code> can be made much shorter
by collecting the first two columns as list of 2-lists and then
converting the 2-lists to key-value pairs in a dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_genetic_code_v2</span>(filename):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">dict</span>([line<span style="color: #666666">.</span>split()[<span style="color: #666666">0</span>:<span style="color: #666666">2</span>] <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)])
</pre></div>
<p>
Creating a mapping of the code onto all the three variants of the amino
acid name is
also of interest. For example, we would like to make look ups like
<code>['CUU']['3-letter']</code> or <code>['CUU']['amino acid']</code>. This requires
a dictionary of dictionaries:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_genetic_code_v3</span>(filename):
    genetic_code <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>):
        columns <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        genetic_code[columns[<span style="color: #666666">0</span>]] <span style="color: #666666">=</span> {}
        genetic_code[columns[<span style="color: #666666">0</span>]][<span style="color: #BA2121">&#39;1-letter&#39;</span>]   <span style="color: #666666">=</span> columns[<span style="color: #666666">1</span>]
        genetic_code[columns[<span style="color: #666666">0</span>]][<span style="color: #BA2121">&#39;3-letter&#39;</span>]   <span style="color: #666666">=</span> columns[<span style="color: #666666">2</span>]
        genetic_code[columns[<span style="color: #666666">0</span>]][<span style="color: #BA2121">&#39;amino acid&#39;</span>] <span style="color: #666666">=</span> columns[<span style="color: #666666">3</span>]
    <span style="color: #008000; font-weight: bold">return</span> genetic_code
</pre></div>
<p>
An alternative way of writing the last function is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_genetic_code_v4</span>(filename):
    genetic_code <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>):
        c <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        genetic_code[c[<span style="color: #666666">0</span>]] <span style="color: #666666">=</span> {
            <span style="color: #BA2121">&#39;1-letter&#39;</span>: c[<span style="color: #666666">1</span>], <span style="color: #BA2121">&#39;3-letter&#39;</span>: c[<span style="color: #666666">2</span>], <span style="color: #BA2121">&#39;amino acid&#39;</span>: c[<span style="color: #666666">3</span>]}
    <span style="color: #008000; font-weight: bold">return</span> genetic_code
</pre></div>
<p>
To form mRNA, we need to grab the exon regions (the coding parts) of
the lactase gene.  These regions are substrings of the lactase gene
DNA string, corresponding to the start and end positions of the exon
regions.  Then we must replace T by U, and combine all the substrings
to build the mRNA string.

<p>
Two straightforward subtasks are to load the lactase gene and its exon
positions into variables.  The file <code>lactase_gene.txt</code>, at the same
Internet location as the other files, stores the lactase gene. The file
has the same format as <code>yeast_chr1.txt</code>. Using the <code>download</code> function
and the previously shown <code>read_dnafile_v1</code>, we can easily load the
data in the file into the string <code>lactase_gene</code>.

<p>
The exon regions are described in a file <code>lactase_exon.tsv</code>, also
found at the same Internet site as the other files. The file is easily
transferred to your computer by calling <code>download</code>.  The file format
is very simple in that each line holds the start and end positions of
an exon region:
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">0       651
3990    4070
7504    7588
13177   13280
15082   15161
</pre></div>
<p>
We want to have this information available in a list of (start, end)
tuples. The following function does the job:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_exon_regions_v1</span>(filename):
    positions <span style="color: #666666">=</span> []
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        start, end <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        start, end <span style="color: #666666">=</span> <span style="color: #008000">int</span>(start), <span style="color: #008000">int</span>(end)
        positions<span style="color: #666666">.</span>append((start, end))
    infile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">return</span> positions
</pre></div>
<p>
Readers favoring compact code will appreciate this alternative version
of the function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_exon_regions_v2</span>(filename):
    <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #008000">tuple</span>(<span style="color: #008000">int</span>(x) <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> line<span style="color: #666666">.</span>split())
            <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)]

lactase_exon_regions <span style="color: #666666">=</span> read_exon_regions_v2(lactase_exon_file)
</pre></div>
<p>
For simplicity's sake, we shall consider mRNA as the concatenation of exons,
although in reality, additional base pairs are added to each end.
Having the lactase gene as a string and the exon regions as a list of
(start, end) tuples, it is straightforward to extract the regions
as substrings, replace T by U, and add all the substrings together:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create_mRNA</span>(gene, exon_regions):
    mrna <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> start, end <span style="color: #AA22FF; font-weight: bold">in</span> exon_regions:
        mrna <span style="color: #666666">+=</span> gene[start:end]<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;T&#39;</span>,<span style="color: #BA2121">&#39;U&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> mrna

mrna <span style="color: #666666">=</span> create_mRNA(lactase_gene, lactase_exon_regions)
</pre></div>
<p>
We would like to store the mRNA string in a file, using the same
format as <code>lactase_gene.txt</code> and <code>yeast_chr1.txt</code>, i.e.,
the string is split on multiple lines with, e.g., 70 characters per line.
An appropriate function doing this is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tofile_with_line_sep_v1</span>(text, filename, chars_per_line<span style="color: #666666">=70</span>):
    outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;w&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #666666">0</span>, <span style="color: #008000">len</span>(text), chars_per_line):
        start <span style="color: #666666">=</span> i
        end <span style="color: #666666">=</span> start <span style="color: #666666">+</span> chars_per_line
        outfile<span style="color: #666666">.</span>write(text[start:end] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
    outfile<span style="color: #666666">.</span>close()
</pre></div>
<p>
It might be convenient to have a separate folder for files that we create.
Python has good support for testing if a folder exists, and if not,
make a folder:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">output_folder <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;output&#39;</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isdir(output_folder):
    os<span style="color: #666666">.</span>mkdir(output_folder)
filename <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(output_folder, <span style="color: #BA2121">&#39;lactase_mrna.txt&#39;</span>)
tofile_with_line_sep_v1(mrna, filename)
</pre></div>
<p>
Python's term for folder is directory, which explains why <code>isdir</code> is
the function name for testing on a folder existence. Observe
especially that the combination of a folder and a filename is done via
<code>os.path.join</code> rather than just inserting a forward slash, or backward
slash on Windows: <code>os.path.join</code> will insert the right slash, forward
or backward, depending on the current operating system.

<p>
Occasionally, the output folder is nested, say
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">output_folder <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(<span style="color: #BA2121">&#39;output&#39;</span>, <span style="color: #BA2121">&#39;lactase&#39;</span>)
</pre></div>
<p>
In that case, <code>os.mkdir(output_folder)</code> may fail because the
intermediate folder <code>output</code> is missing. Making a folder and also all
missing intermediate folders is done by <code>os.makedirs</code>.  We can write a
more general file writing function that takes a folder name and file
name as input and writes the file.  Let us also add some flexibility
in the file format: one can either write a fixed number of characters
per line, or have the string on just one long line. The latter version
is specified through <code>chars_per_line='inf'</code> (for infinite number of
characters per line).  The flexible file writing function then becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tofile_with_line_sep_v2</span>(text, foldername, filename,
                            chars_per_line<span style="color: #666666">=70</span>):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isdir(foldername):
        os<span style="color: #666666">.</span>makedirs(foldername)
    filename <span style="color: #666666">=</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(foldername, filename)
    outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;w&#39;</span>)

    <span style="color: #008000; font-weight: bold">if</span> chars_per_line <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;inf&#39;</span>:
        outfile<span style="color: #666666">.</span>write(text)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #666666">0</span>, <span style="color: #008000">len</span>(text), chars_per_line):
            start <span style="color: #666666">=</span> i
            end <span style="color: #666666">=</span> start <span style="color: #666666">+</span> chars_per_line
            outfile<span style="color: #666666">.</span>write(text[start:end] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>)
    outfile<span style="color: #666666">.</span>close()
</pre></div>
<p>
To create the protein, we replace the triplets of the mRNA strings
by the corresponding 1-letter name as specified in the
<code>genetic_code.tsv</code> file.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create_protein</span>(mrna, genetic_code):
    protein <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #008000">len</span>(mrna)<span style="color: #666666">/3</span>):
        start <span style="color: #666666">=</span> i <span style="color: #666666">*</span> <span style="color: #666666">3</span>
        end <span style="color: #666666">=</span> start <span style="color: #666666">+</span> <span style="color: #666666">3</span>
        protein <span style="color: #666666">+=</span> genetic_code[mrna[start:end]]
    <span style="color: #008000; font-weight: bold">return</span> protein

genetic_code <span style="color: #666666">=</span> read_genetic_code_v1(<span style="color: #BA2121">&#39;genetic_code.tsv&#39;</span>)
protein <span style="color: #666666">=</span> create_protein(mrna, genetic_code)
tofile_with_line_sep_v2(protein, <span style="color: #BA2121">&#39;output&#39;</span>,
</pre></div>
<p>
Unfortunately, this first try to simulate the translation process is
incorrect. The problem is that the translation always begins with the
amino acid Methionine, code AUG, and ends when one of the stop codons
is met. We must thus check for the correct start and stop criteria.
A fix is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">create_protein_fixed</span>(mrna, genetic_code):
    protein_fixed <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&#39;</span>
    trans_start_pos <span style="color: #666666">=</span> mrna<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;AUG&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(mrna[trans_start_pos:])<span style="color: #666666">/3</span>):
        start <span style="color: #666666">=</span> trans_start_pos <span style="color: #666666">+</span> i<span style="color: #666666">*3</span>
        end <span style="color: #666666">=</span> start <span style="color: #666666">+</span> <span style="color: #666666">3</span>
        amino <span style="color: #666666">=</span> genetic_code[mrna[start:end]]
        <span style="color: #008000; font-weight: bold">if</span> amino <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;X&#39;</span>:
            <span style="color: #008000; font-weight: bold">break</span>
        protein_fixed <span style="color: #666666">+=</span> amino
    <span style="color: #008000; font-weight: bold">return</span> protein_fixed

protein <span style="color: #666666">=</span> create_protein_fixed(mrna, genetic_code)
tofile_with_line_sep_v2(protein, <span style="color: #BA2121">&#39;output&#39;</span>,
                        <span style="color: #BA2121">&#39;lactase_protein_fixed.txt&#39;</span>, <span style="color: #666666">70</span>)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;10 last amino acids of the correct lactase protein: &#39;</span>, \ 
      protein[<span style="color: #666666">-10</span>:]
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Lenght of the correct protein: &#39;</span>, <span style="color: #008000">len</span>(protein)
</pre></div>
<p>
The output, needed below for comparison, becomes
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">10 last amino acids of the correct lactase protein:  QQELSPVSSF
Lenght of the correct protein:  1927
</pre></div>

<h2 id="bioinf:lactase:milk">Some humans can drink milk, while others cannot<a name="bioinf:lactase:milk"></a></h2>

One type of lactose intolerance is called <em>Congenital lactase deficiency</em>.
This is a rare genetic disorder that causes lactose intolerance from birth,
and is particularly common in Finland. The disease is caused by a mutation of
the base in position 30049 (0-based) of the lactase gene, a mutation from T to
A. Our goal is to check what happens to the protein if this base is mutated.
This is a simple task using the previously developed tools:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">congential_lactase_deficiency</span>(
    lactase_gene,
    genetic_code,
    lactase_exon_regions,
    output_folder<span style="color: #666666">=</span>os<span style="color: #666666">.</span>curdir,
    mrna_file<span style="color: #666666">=</span><span style="color: #008000">None</span>,
    protein_file<span style="color: #666666">=</span><span style="color: #008000">None</span>):

    pos <span style="color: #666666">=</span> <span style="color: #666666">30049</span>
    mutated_gene <span style="color: #666666">=</span> lactase_gene[:pos] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;A&#39;</span> <span style="color: #666666">+</span> lactase_gene[pos<span style="color: #666666">+1</span>:]
    mutated_mrna <span style="color: #666666">=</span> create_mRNA(mutated_gene, lactase_exon_regions)

    <span style="color: #008000; font-weight: bold">if</span> mrna_file <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        tofile_with_line_sep_v2(
            mutated_mrna, output_folder, mrna_file)

    mutated_protein <span style="color: #666666">=</span> create_protein_fixed(
        mutated_mrna, genetic_code)

    <span style="color: #008000; font-weight: bold">if</span> protein_file:
        tofile_with_line_sep_v2(
            mutated_protein, output_folder, protein_file)
    <span style="color: #008000; font-weight: bold">return</span> mutated_protein

mutated_protein <span style="color: #666666">=</span> congential_lactase_deficiency(
    lactase_gene, genetic_code, lactase_exon_regions,
    output_folder<span style="color: #666666">=</span><span style="color: #BA2121">&#39;output&#39;</span>,
    mrna_file<span style="color: #666666">=</span><span style="color: #BA2121">&#39;mutated_lactase_mrna.txt&#39;</span>,
    protein_file<span style="color: #666666">=</span><span style="color: #BA2121">&#39;mutated_lactase_protein.txt&#39;</span>)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;10 last amino acids of the mutated lactase protein:&#39;</span>, \ 
      mutated_protein[<span style="color: #666666">-10</span>:]
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Lenght of the mutated lactase protein:&#39;</span>, \ 
      <span style="color: #008000">len</span>(mutated_protein)
</pre></div>
<p>
The output, to be compared with the non-mutated gene above, is now
<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">10 last amino acids of the mutated lactase protein: GFIWSAASAA
Lenght of the mutated lactase protein: 1389
</pre></div>
<p>
As we can see, the translation stops prematurely, creating a much smaller
protein, which will not have the required characteristics of the lactase
protein.

<p>
A couple of mutations in a region for LCT located in front of LCT (actually in
the introns of another gene) is the reason for the common lactose intolerance.
That is, the one that sets in for adults only. These mutations control the
expression of the LCT gene, i.e., whether that the gene is turned on or off.
Interestingly, different mutations have evolved in different regions of the
world, e.g., Africa and Northern Europe. This is an example of convergent
evolution: the acquisition of the same biological trait in unrelated
lineages. The prevalence of lactose intolerance varies widely, from around 5%
in northern Europe, to close to 100% in south-east Asia.

<p>
The functions analyzing the lactase gene are found
in the file <a href="http://tinyurl.com/pwyasaa/files/genes2proteins.py" target="_self"><tt>genes2proteins.py</tt></a>.

<h1 id="___sec70">Summary <a name="___sec70"></a></h1>

<h2 id="___sec71">Chapter topics <a name="___sec71"></a></h2>

<h3 id="___sec72">Dictionaries <a name="___sec72"></a></h3>

Array or list-like objects with text or other (fixed-valued) Python
objects as indices are called dictionaries. They are very useful for
storing general collections of objects in a single data structure.
The table below displays some of the most important dictionary
operations.

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>                               Construction                              </b></td> <td align="center"><b>                                 Meaning                                 </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   <code>a = {}</code>                                                          </td> <td align="left">   initialize an empty dictionary                                               </td> </tr>
<tr><td align="left">   <code>a = {'point': [0,0.1], 'value': 7}</code>                              </td> <td align="left">   initialize a dictionary                                                      </td> </tr>
<tr><td align="left">   <code>a = dict(point=[2,7], value=3)</code>                                  </td> <td align="left">   initialize a dictionary w/string keys                                        </td> </tr>
<tr><td align="left">   <code>a.update(b)</code>                                                     </td> <td align="left">   add/update key-value pairs from <code>b</code> in <code>a</code>             </td> </tr>
<tr><td align="left">   <code>a.update(key1=value1, key2=value2)</code>                              </td> <td align="left">   add/update key-value pairs in <code>a</code>                                 </td> </tr>
<tr><td align="left">   <code>a['hide'] = True</code>                                                </td> <td align="left">   add new key-value pair to <code>a</code>                                     </td> </tr>
<tr><td align="left">   <code>a['point']</code>                                                      </td> <td align="left">   get value corresponding to key <code>point</code>                            </td> </tr>
<tr><td align="left">   <code>for key in a:</code>                                                   </td> <td align="left">   loop over keys in unknown order                                              </td> </tr>
<tr><td align="left">   <code>for key in sorted(a):</code>                                           </td> <td align="left">   loop over keys in alphabetic order                                           </td> </tr>
<tr><td align="left">   <code>'value' in a</code>                                                    </td> <td align="left">   <code>True</code> if string <code>value</code> is a key in <code>a</code>    </td> </tr>
<tr><td align="left">   <code>del a['point']</code>                                                  </td> <td align="left">   delete a key-value pair from <code>a</code>                                  </td> </tr>
<tr><td align="left">   <code>list(a.keys())</code>                                                  </td> <td align="left">   list of keys                                                                 </td> </tr>
<tr><td align="left">   <code>list(a.values())</code>                                                </td> <td align="left">   list of values                                                               </td> </tr>
<tr><td align="left">   <code>len(a)</code>                                                          </td> <td align="left">   number of key-value pairs in <code>a</code>                                  </td> </tr>
<tr><td align="left">   <code>isinstance(a, dict)</code>                                             </td> <td align="left">   is <code>True</code> if <code>a</code> is a dictionary                       </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->

<h3 id="___sec73">Strings <a name="___sec73"></a></h3>

Some of the most useful functionalities in a string object <code>s</code> are
listed below.

<p>
<b>Split</b> the string into substrings separated by <code>delimiter</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">words <span style="color: #666666">=</span> s<span style="color: #666666">.</span>split(delimiter)
</pre></div>
<p>
<b>Join</b> elements in a list of strings:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">newstring <span style="color: #666666">=</span> delimiter<span style="color: #666666">.</span>join(words[i:j])
</pre></div>
<p>
Extract a <b>substring</b>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">substring <span style="color: #666666">=</span> s[<span style="color: #666666">2</span>:n<span style="color: #666666">-4</span>]
</pre></div>
<p>
<b>Replace</b> a substring <code>substr</code> by new a string <code>replacement</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">s_new <span style="color: #666666">=</span> s<span style="color: #666666">.</span>replace(substr, replacement)
</pre></div>
<p>
Check if a substring <b>is contained</b> within another string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;some text&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> s:
    <span style="color: #666666">...</span>
</pre></div>
<p>
<b>Find</b> the index where some text starts:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">index <span style="color: #666666">=</span> s<span style="color: #666666">.</span>find(text)
<span style="color: #008000; font-weight: bold">if</span> index <span style="color: #666666">==</span> <span style="color: #666666">-1</span>:
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Could not find &quot;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot; in &quot;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&quot; (text, s)</span>
<span style="color: #008000; font-weight: bold">else</span>:
    substring <span style="color: #666666">=</span> s[index:]  <span style="color: #408080; font-style: italic"># strip off chars before text</span>
</pre></div>
<p>
<b>Extend</b> a string:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">s <span style="color: #666666">+=</span> another_string     <span style="color: #408080; font-style: italic"># append at the end</span>
s <span style="color: #666666">=</span> another_string <span style="color: #666666">+</span> s  <span style="color: #408080; font-style: italic"># append at the beginning</span>
</pre></div>
<p>
Check if a string contains <b>whitespace only</b>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> s<span style="color: #666666">.</span>isspace():
   <span style="color: #666666">...</span>
</pre></div>
<p>
Note: you cannot change the characters in a string like you can change
elements in a list (a string is in this sense like a tuple). You have to
make a new string:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;myfile1.txt&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> filename[<span style="color: #666666">6</span>] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;2&#39;</span>
Traceback (most recent call last):
  <span style="color: #666666">...</span>
<span style="color: #D2413A; font-weight: bold">TypeError</span>: <span style="color: #BA2121">&#39;str&#39;</span> <span style="color: #008000">object</span> does <span style="color: #AA22FF; font-weight: bold">not</span> support item assignment
<span style="color: #666666">&gt;&gt;&gt;</span> filename<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;1&#39;</span>, <span style="color: #BA2121">&#39;2&#39;</span>)
<span style="color: #BA2121">&#39;myfile2.txt&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> filename[:<span style="color: #666666">6</span>] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;2&#39;</span> <span style="color: #666666">+</span> filename[<span style="color: #666666">7</span>:]   <span style="color: #408080; font-style: italic"># &#39;myfile&#39; + &#39;2&#39; + &#39;.txt&#39;</span>
<span style="color: #BA2121">&#39;myfile2.txt&#39;</span>
</pre></div>

<h3 id="___sec74">Downloading Internet files <a name="___sec74"></a></h3>

Internet files can be downloaded if we know their URL:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">urllib</span>
url <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;http://www.some.where.net/path/thing.html&#39;</span>
urllib<span style="color: #666666">.</span>urlretrieve(url, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;thing.html&#39;</span>)
</pre></div>
<p>
The downloaded information is put in the local file <code>thing.html</code>
in the current working folder.
Alternatively, we can open the URL as a file object:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">webpage <span style="color: #666666">=</span> urllib<span style="color: #666666">.</span>urlopen(url)
</pre></div>
<p>
HTML files are often messy to interpret by string operations.

<h3 id="___sec75">Terminology <a name="___sec75"></a></h3>

The important computer science topics in this document are

<ul>
  <li> dictionaries</li>
  <li> strings and string operations</li>
  <li> CSV files</li>
  <li> HTML files</li>
</ul>

<h2 id="sec:files:sumex">Example: A file database<a name="sec:files:sumex"></a></h2>

<!-- names: www.funnyname.com/anonymous.html -->
<!-- Ola Nordmann -->
<!-- Chan Siu Ming -->
<!-- Ivan Horvat -->
<!-- Jan Met De Pet -->
<!-- Fred Nurk -->
<!-- Joe Bloggs -->
<!-- I. U. Ajn -->
<!-- Matti Meikalainen (ala skal ha a med todler) -->
<!-- Jean Dupont -->
<!-- Otto Normalverbraucher -->
<!-- Erika Mustermann -->
<!-- Hans Meier -->
<!-- Israel Israeli -->
<!-- Jona Jonsdottir (med akksent over hver o) -->
<!-- Si Polan -->
<!-- Mario Rossi -->
<!-- Nanashi No Gombe -->
<!-- Jonas Jonaitis -->
<!-- Jan Kowalski -->
<!-- Vasya Pupkin -->
<!-- Jovan Petrovic -->
<!-- Juan del Pueblo -->
<!-- Juan dela Cruz -->
<!-- Sipho Nkosi -->
<!-- Nguoi La -->

<h3 id="___sec77">Problem <a name="___sec77"></a></h3>

We have a file containing information about the courses that students have
taken.
The file format consists of blocks with student data, where each
block starts with the student's name (<code>Name:</code>), followed by
the courses that the student has taken. Each course line starts with the
name of the course, then comes the semester when the exam was taken,
then the size of the course in terms of credit points,
and finally the grade is listed (letters <code>A</code> to <code>F</code>).
Here is an example of a file with three student entries:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Name: John Doe
Astronomy                         2003 fall 10 A
Introductory Physics              2003 fall 10 C
Calculus I                        2003 fall 10 A
Calculus II                       2004 spring 10 B
Linear Algebra                    2004 spring 10 C
Quantum Mechanics I               2004 fall 10 A
Quantum Mechanics II              2005 spring 10 A
Numerical Linear Algebra          2004 fall 5 E
Numerical Methods                 2004 spring 20 C

Name: Jan Modaal
Calculus I                        2005 fall 10 A
Calculus II                       2006 spring 10 A
Introductory C++ Programming      2005 fall 15 D
Introductory Python Programming   2006 spring 5 A
Astronomy                         2005 fall 10 A
Basic Philosophy                  2005 fall 10 F

Name: Kari Nordmann
Introductory Python Programming   2006 spring 5 A
Astronomy                         2005 fall 10 D
</pre></div>
<p>
Our problem consists of reading this file into a dictionary <code>data</code>
with the
student name as key and a list of courses as value.
Each element in the list of courses is a dictionary holding the
course name, the semester, the credit points, and the grade.
A value in the <code>data</code> dictionary may look as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121">&#39;Kari Nordmann&#39;</span>: [{<span style="color: #BA2121">&#39;credit&#39;</span>: <span style="color: #666666">5</span>,
                   <span style="color: #BA2121">&#39;grade&#39;</span>: <span style="color: #BA2121">&#39;A&#39;</span>,
                   <span style="color: #BA2121">&#39;semester&#39;</span>: <span style="color: #BA2121">&#39;2006 spring&#39;</span>,
                   <span style="color: #BA2121">&#39;title&#39;</span>: <span style="color: #BA2121">&#39;Introductory Python Programming&#39;</span>},
                  {<span style="color: #BA2121">&#39;credit&#39;</span>: <span style="color: #666666">10</span>,
                   <span style="color: #BA2121">&#39;grade&#39;</span>: <span style="color: #BA2121">&#39;D&#39;</span>,
                   <span style="color: #BA2121">&#39;semester&#39;</span>: <span style="color: #BA2121">&#39;2005 fall&#39;</span>,
                   <span style="color: #BA2121">&#39;title&#39;</span>: <span style="color: #BA2121">&#39;Astronomy&#39;</span>}],
</pre></div>
<p>
Having the <code>data</code> dictionary, the next task is to print out the
average grade of each student.

<h3 id="___sec78">Solution <a name="___sec78"></a></h3>

We divide the problem into two major tasks: loading the file data into
the <code>data</code> dictionary, and computing the average grades.
These two tasks are naturally placed in two functions.

<p>
We need to have a strategy for reading the file and interpreting the
contents. It will be natural to read the file line by line, and for
each line check if this is a line containing a new student's name,
a course information line, or a blank line.
In the latter case we jump to the next pass in the loop. When a
new student name is encountered, we initialize a new entry in the
<code>data</code> dictionary to an empty list. In the case of a line about
a course, we must interpret the contents on that line, which we
postpone a bit.

<p>
We can now sketch the algorithm described above in terms of some
unfinished Python code, just to get the overview:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">load</span>(studentfile):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(studentfile, <span style="color: #BA2121">&#39;r&#39;</span>)
    data <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        i <span style="color: #666666">=</span> line<span style="color: #666666">.</span>find(<span style="color: #BA2121">&#39;Name:&#39;</span>)
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">!=</span> <span style="color: #666666">-1</span>:
            <span style="color: #408080; font-style: italic"># line contains &#39;Name:&#39;, extract the name.</span>
            <span style="color: #666666">...</span>
        <span style="color: #008000; font-weight: bold">elif</span> line<span style="color: #666666">.</span>isspace():     <span style="color: #408080; font-style: italic"># Blank line?</span>
            <span style="color: #008000; font-weight: bold">continue</span>             <span style="color: #408080; font-style: italic"># Yes, go to next loop iteration.</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #408080; font-style: italic"># This must be a course line, interpret the line.</span>
            <span style="color: #666666">...</span>
    infile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">return</span> data
</pre></div>
<p>
If we find <code>'Name:'</code> as a substring in <code>line</code>, we must extract
the name. This can be done by the substring
<code>line[i+5:]</code>. Alternatively, we can split the line with respect to
colon and strip off the first word:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;:&#39;</span>)
name <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join(words[<span style="color: #666666">1</span>:])
</pre></div>
<p>
We have chosen the former strategy of extracting the name as a substring
in the final program.

<p>
Each course line is naturally split into words for extracting
information:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
</pre></div>
<p>
The name of the course consists of a number of words, but we do not know
how many.
Nevertheless, we know that the final words contain the semester, the credit
points, and the grade. We can hence count from the right and extract
information, and when we are finished with the semester information,
the rest of the <code>words</code> list holds the words in the name of the course.
The code goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grade <span style="color: #666666">=</span> words[<span style="color: #666666">-1</span>]
credit <span style="color: #666666">=</span> <span style="color: #008000">int</span>(words[<span style="color: #666666">-2</span>])
semester <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join(words[<span style="color: #666666">-4</span>:<span style="color: #666666">-2</span>])
course_name <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join(words[:<span style="color: #666666">-4</span>])
data[name]<span style="color: #666666">.</span>append({<span style="color: #BA2121">&#39;title&#39;</span>:    course_name,
                   <span style="color: #BA2121">&#39;semester&#39;</span>: semester,
                   <span style="color: #BA2121">&#39;credit&#39;</span>:   credit,
                   <span style="color: #BA2121">&#39;grade&#39;</span>:    grade})
</pre></div>
<p>
This code is a good example of the usefulness of split and join
operations when extracting information from a text.

<p>
Now to the second task of computing the average grade. Since the grades
are letters we cannot compute with them. A natural way to proceed is to
convert the letters to numbers, compute the average number, and then
convert that number back to a letter.
Conversion between letters and numbers is easily represented by a dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">grade2number <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">5</span>, <span style="color: #BA2121">&#39;B&#39;</span>: <span style="color: #666666">4</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">3</span>, <span style="color: #BA2121">&#39;D&#39;</span>: <span style="color: #666666">2</span>, <span style="color: #BA2121">&#39;E&#39;</span>: <span style="color: #666666">1</span>, <span style="color: #BA2121">&#39;F&#39;</span>: <span style="color: #666666">0</span>}
</pre></div>
<p>
To convert from numbers to grades, we construct the inverse dictionary:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">number2grade <span style="color: #666666">=</span> {}
<span style="color: #008000; font-weight: bold">for</span> grade <span style="color: #AA22FF; font-weight: bold">in</span> grade2number:
    number2grade[grade2number[grade]] <span style="color: #666666">=</span> grade
</pre></div>
<p>
In the computation of the average grade we should use a weighted
sum such that larger courses count more than smaller courses.
The weighted mean value of a set of numbers \( r_i \) with weights \( w_i \),
\( i=0,\ldots,n-1 \), is given by

$$
\begin{equation*} {\sum_{i=0}^{n-1} w_ir_i\over\sum_{i=0}^{n-1} w_i}\tp\end{equation*}
$$

This weighted mean value must then be rounded to the nearest integer,
which can be used as key in <code>number2grade</code> to find the corresponding
grade expressed as a letter.
The weight \( w_i \) is naturally taken as the number of credit points
in the course with grade \( r_i \).
The whole process is performed by the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">average_grade</span>(data, name):
    <span style="color: #008000">sum</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>; weights <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> course <span style="color: #AA22FF; font-weight: bold">in</span> data[name]:
        weight <span style="color: #666666">=</span> course[<span style="color: #BA2121">&#39;credit&#39;</span>]
        grade  <span style="color: #666666">=</span> course[<span style="color: #BA2121">&#39;grade&#39;</span>]
        <span style="color: #008000">sum</span> <span style="color: #666666">+=</span> grade2number[grade]<span style="color: #666666">*</span>weight
        weights <span style="color: #666666">+=</span> weight
    avg <span style="color: #666666">=</span> <span style="color: #008000">sum</span><span style="color: #666666">/</span><span style="color: #008000">float</span>(weights)
    <span style="color: #008000; font-weight: bold">return</span> number2grade[<span style="color: #008000">round</span>(avg)]
</pre></div>
<p>
The complete code is found in the file
<a href="http://tinyurl.com/pwyasaa/files/student.py" target="_self"><tt>students.py</tt></a>.
Running this program gives the following output of the average grades:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">John Doe: B
Kari Nordmann: C
Jan Modaal: C
</pre></div>
<p>
One feature of the <code>students.py</code> code is that the output of the names
are sorted after the last name. How can we accomplish that?
A straight <code>for name in data</code> loop will visit the keys in an unknown
(random) order. To visit the keys in alphabetic order, we must
use

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(data):
</pre></div>
<p>
This default sort will sort with respect to the first character in
the <code>name</code> strings. We want a sort according to the last part of
the name. A tailored sort function can then be written (see
ref{sec:basic:ex28} for an introduction to tailored
sort functions). In this function we
extract the last word in the names and compare them:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sort_names</span>(name1, name2):
    last_name1 <span style="color: #666666">=</span> name1<span style="color: #666666">.</span>split()[<span style="color: #666666">-1</span>]
    last_name2 <span style="color: #666666">=</span> name2<span style="color: #666666">.</span>split()[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">if</span> last_name1 <span style="color: #666666">&lt;</span> last_name2:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-1</span>
    <span style="color: #008000; font-weight: bold">elif</span> last_name1 <span style="color: #666666">&gt;</span> last_name2:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
</pre></div>
<p>
We can now pass on <code>sort_names</code> to the <code>sorted</code> function to
get a sequence that is sorted with respect to the last word in the students'
names:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(data, sort_names):
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (name, average_grade(data, name))
</pre></div>

<h1 id="sec:files:exercises">Exercises<a name="sec:files:exercises"></a></h1>

<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2b:basic">Exercise 1: Make a dictionary from a table<a name="sec:files:ex2b:basic"></a></h2>

The file <a href="http://tinyurl.com/pwyasaa/files/constants.txt" target="_self"><tt>src/files/constants.txt</tt></a> contains a table of the values and
the dimensions of some fundamental constants from physics.  We want to
load this table into a dictionary <code>constants</code>, where the keys are the
names of the constants. For example, <code>constants['gravitational
constant']</code> holds the value of the gravitational constant
(\( 6.67259\cdot 10^{-11} \)) in Newton's law of gravitation.  Make a
function that reads and interprets the text in the file, and
finally returns the dictionary.
Filename: <code>fundamental_constants.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2">Exercise 2: Explore syntax differences: lists vs. dicts<a name="sec:files:ex2"></a></h2>

Consider this code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t1 <span style="color: #666666">=</span> {}
t1[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-5</span>
t1[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">10.5</span>
</pre></div>
<p>
Explain why the lines above work fine while the ones below do not:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t2 <span style="color: #666666">=</span> []
t2[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-5</span>
t2[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">10.5</span>
</pre></div>
<p>
What must be done in the last code snippet to make it work properly?
Filename: <code>list_vs_dict.py</code>.

<p>
<!-- best for teaching, not students -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex17">Exercise 3: Use string operations to improve a program<a name="sec:files:ex17"></a></h2>

Consider the program <code>density.py</code> from the section <a href="#sec:files:dict:density">Example: File data in dictionaries</a>.  One problem we face when implementing
this program is that the name of the substance can contain one or two
words, and maybe more words in a more comprehensive table.  The
purpose of this exercise is to use string operations to shorten the
code and make it more general.

<p>
<b>a)</b>
Make a Python function that lets <code>substance</code> consist of all the
words but the last,
using the <code>join</code> method in string objects to combine the words.

<p>
<b>b)</b>
Observe that all the densities start in the same column.
Write an alternative function that makes use of
substring indexing to divide <code>line</code> into two parts.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Remember to strip the first part such that, e.g.,
the density of ice is obtained as <code>densities['ice']</code> and not
<code>densities['ice         ']</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Make a test function that calls the two other functions and
tests that they produce the same result.

<p>
Filename: <code>density_improved.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex13">Exercise 4: Interpret output from a program<a name="sec:files:ex13"></a></h2>

The program <a href="http://tinyurl.com/pwyasaa/funcif/lnsum.py" target="_self"><tt>src/funcif/lnsum.py</tt></a>
produces, among other things, this output:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">epsilon: 1e-04, exact error: 8.18e-04, n=55
epsilon: 1e-06, exact error: 9.02e-06, n=97
epsilon: 1e-08, exact error: 8.70e-08, n=142
epsilon: 1e-10, exact error: 9.20e-10, n=187
epsilon: 1e-12, exact error: 9.31e-12, n=233
</pre></div>
</blockquote><p>
Redirect the output to a file (by <code>python lnsum.py > file</code>).
Write a Python program that reads the file and extracts
the numbers corresponding to <code>epsilon</code>, <code>exact error</code>,
and <code>n</code>. Store the numbers in three arrays and plot
<code>epsilon</code> and the <code>exact error</code> versus <code>n</code>.
Use a logarithmic scale on the \( y \) axis.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
The function <code>semilogy</code> is
an alternative to <code>plot</code> and gives logarithmic scale on \( y \) axis.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>read_error.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2b">Exercise 5: Make a dictionary<a name="sec:files:ex2b"></a></h2>

Based on the stars data in ref{sec:basic:ex28},
make a dictionary where the keys contain the names of the stars
and the values correspond to the luminosity.
Filename: <code>stars_data_dict1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2c">Exercise 6: Make a nested dictionary<a name="sec:files:ex2c"></a></h2>

Store the data about stars from ref{sec:basic:ex28}
in a nested dictionary such that we can look up the
distance, the apparent brightness, and the luminosity of a star with
name <code>N</code> by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">stars[N][<span style="color: #BA2121">&#39;distance&#39;</span>]
stars[N][<span style="color: #BA2121">&#39;apparent brightness&#39;</span>]
stars[N][<span style="color: #BA2121">&#39;luminosity&#39;</span>]
</pre></div>
<p>
Filename: <code>stars_data_dict2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2d:nested">Exercise 7: Make a nested dictionary from a file<a name="sec:files:ex2d:nested"></a></h2>

The file <a href="http://tinyurl.com/pwyasaa/files/human_evolution.txt" target="_self"><tt>src/files/human_evolution.txt</tt></a> holds information about
various human species and their height, weight, and brain volume.
Make a program that reads this file and stores the tabular data in
a nested dictionary <code>humans</code>. The keys in <code>humans</code> correspond
to the specie name (e.g., <code>homo erectus</code>), and the values are
dictionaries with keys for <code>height</code>, <code>weight</code>, <code>brain volume</code>,
and <code>when</code> (the latter for when the specie lived).
For example, <code>humans['homo neanderthalensis']['mass']</code> should
equal <code>'55-70'</code>. Let the program write out the <code>humans</code>
dictionary in a nice tabular form similar to that in the file.
Filename: <code>humans.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2d:nested2">Exercise 8: Make a nested dictionary from a file<a name="sec:files:ex2d:nested2"></a></h2>

The viscosity \( \mu \) of gases depends on the temperature.
For some gases the following formula is relevant:

$$ \mu (T) = \mu_0\frac{T_0-C}{T+C}\left(\frac{T}{T_0}\right)^{1.5},$$

where the values of the constants \( C \), \( T_0 \), and \( \mu_0 \) are
found in the file
<a href="http://tinyurl.com/pwyasaa/files/viscosity_of_gases.txt" target="_self"><tt>src/files/viscosity_of_gases.dat</tt></a>. The temperature is measured in Kelvin.

<p>
<b>a)</b>
Load the file into a nested dictionary <code>mu_data</code> such that we can
look up \( C \), \( T_0 \), and \( \mu_0 \) for a gas with name <code>name</code> by
<code>mu_data[name][X]</code>, where <code>X</code> is <code>'C'</code> for \( C \),
<code>'T_0'</code> for \( T_0 \), and <code>'mu_0'</code> for \( \mu_0 \).

<p>
<b>b)</b>
Make a function <code>mu(T, gas, mu_data)</code> for computing \( \mu(T) \) for a
gas with name <code>gas</code> (according to the file) and information about
constants \( C \), \( T_0 \), and \( \mu_0 \) in <code>mu_data</code>.

<p>
<b>c)</b>
Plot \( \mu(T) \) for air, carbon dioxide, and hydrogen with
\( T\in [223, 373] \).

<p>
Filename: <code>viscosity_of_gases.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex2d">Exercise 9: Compute the area of a triangle<a name="sec:files:ex2d"></a></h2>

The purpose of this exercise is to write
an <code>area</code> function as in ref{sec:basic:ex25},
but now we assume that the vertices of the triangle is stored in
a dictionary and not a list. The keys in the dictionary correspond to
the vertex number (1, 2, or 3) while the values are 2-tuples with the
\( x \) and \( y \) coordinates of the vertex. For example,
in a triangle with vertices \( (0,0) \), \( (1,0) \), and \( (0,2) \) the
<code>vertices</code> argument becomes

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">{1: (0,0), 2: (1,0), 3: (0,2)}
</pre></div>
</blockquote><p>
Filename: <code>area_triangle_dict.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex16">Exercise 10: Compare data structures for polynomials<a name="sec:files:ex16"></a></h2>

Write a code snippet that uses both a list and a dictionary to
represent the polynomial \( -\frac{1}{2} + 2x^{100} \).
Print the list and the dictionary, and use them
to evaluate the polynomial for \( x=1.05 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can apply the <code>poly1</code>
and <code>poly2</code> functions from the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>).

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>poly_repr.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex3">Exercise 11: Compute the derivative of a polynomial<a name="sec:files:ex3"></a></h2>

A polynomial can be represented by a dictionary as explained
in the section <a href="#sec:files:poly">Example: Polynomials as dictionaries</a>.
Write a function <code>diff</code> for differentiating such a polynomial.
The <code>diff</code> function takes the polynomial as a dictionary argument
and returns the dictionary representation
of the derivative.
Here is an example of
the use of the function <code>diff</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> p <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #666666">-3</span>, <span style="color: #666666">3</span>: <span style="color: #666666">2</span>, <span style="color: #666666">5</span>: <span style="color: #666666">-1</span>}    <span style="color: #408080; font-style: italic"># -3 + 2*x**3 - x**5</span>
<span style="color: #666666">&gt;&gt;&gt;</span> diff(p)                     <span style="color: #408080; font-style: italic"># should be 6*x**2 - 5*x**4</span>
{<span style="color: #666666">2</span>: <span style="color: #666666">6</span>, <span style="color: #666666">4</span>: <span style="color: #666666">-5</span>}
</pre></div>
<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Recall the formula for differentiation of polynomials:

$$
\begin{equation}
{d\over dx}\sum_{j=0}^n c_jx^j = \sum_{j=1}^{n} jc_jx^{j-1}\tp
\tag{1}
\end{equation}
$$

This means that the coefficient of the \( x^{j-1} \) term in the derivative
equals \( j \) times the coefficient of \( x^j \) term of the original polynomial.
With <code>p</code> as the polynomial dictionary and <code>dp</code>
as the dictionary representing the derivative, we then have
<code>dp[j-1] = j*p[j]</code> for <code>j</code> running over all keys in <code>p</code>,
except when <code>j</code> equals 0.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>poly_diff.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:ex10">Exercise 12: Specify functions on the command line<a name="sec:basic:ex10"></a></h2>

Explain what the following two code snippets do and give an example of how
they can be used.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Read about the <code>StringFunction</code> tool
in the document <a href="http://tcse6.on.net/input" target="_self">User input and error handling</a> <a href="#Langtangen_TCSE6_input">[2]</a>
and about a variable number of keyword
arguments in the document <a href="http://tcse6.on.net/varargs" target="_self">Variable number of function arguments in Python</a> <a href="#Langtangen_TCSE6_varargs">[3]</a>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>a)</b>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.StringFunction</span> <span style="color: #008000; font-weight: bold">import</span> StringFunction
parameters <span style="color: #666666">=</span> {}
<span style="color: #008000; font-weight: bold">for</span> prm <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">4</span>:]:
    key, value <span style="color: #666666">=</span> prm<span style="color: #666666">.</span>split(<span style="color: #BA2121">&#39;=&#39;</span>)
    parameters[key] <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(value)
f <span style="color: #666666">=</span> StringFunction(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>], independent_variables<span style="color: #666666">=</span>sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>],
                   <span style="color: #666666">**</span>parameters)
var <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
<span style="color: #008000; font-weight: bold">print</span> f(var)
</pre></div>
<p>
<b>b)</b>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.StringFunction</span> <span style="color: #008000; font-weight: bold">import</span> StringFunction
f <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(<span style="color: #BA2121">&#39;StringFunction(sys.argv[1], &#39;</span> <span style="color: #666666">+</span> \ 
         <span style="color: #BA2121">&#39;independent_variables=sys.argv[2], </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> \ 
         (<span style="color: #BA2121">&#39;, &#39;</span><span style="color: #666666">.</span>join(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">4</span>:])))
var <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
<span style="color: #008000; font-weight: bold">print</span> f(var)
</pre></div>
<p>
Filename: <code>cml_functions.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:basic:ex10b">Exercise 13: Interpret function specifications<a name="sec:basic:ex10b"></a></h2>

To specify arbitrary functions \( f(x_1,x_2,\ldots; p_1, p_2, \ldots) \)
with independent variables \( x_1, x_2, \ldots \) and a set of
parameters \( p_1, p_2, \ldots \),
we allow the following syntax on the command line or in
a file:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&lt;expression&gt; is function of &lt;list1&gt; with parameter &lt;list2&gt;
</pre></div>
</blockquote><p>
where <code><expression></code> denotes the function formula,
<code><list1></code> is a comma-separated list of the independent variables,
and <code><list2></code> is a comma-separated list of name=value parameters. The part
<code>with parameters <list2></code> is omitted if there are no parameters.
The names of the independent variables and the parameters can be
chosen freely as long as the names can be used as Python variables.
Here are four different examples of what we can specify on the
command line using this syntax:

<p>

<!-- code=text (!bc ccq) typeset with pygments style "default" -->
<blockquote>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">sin(x) is a function of x
sin(a*y) is a function of y with parameter a=2
sin(a*x-phi) is a function of x with parameter a=3, phi=-pi
exp(-a*x)*cos(w*t) is a function of t with parameter a=1,w=pi,x=2
</pre></div>
</blockquote><p>
Create a Python function that takes such function specifications as input
and returns an appropriate <code>StringFunction</code> object.
This object must be created from the function expression and the list
of independent variables and parameters. For example, the last
function specification above leads to the following <code>StringFunction</code>
creation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> StringFunction(<span style="color: #BA2121">&#39;exp(-a*x)*cos(w*t)&#39;</span>,
                   independent_variables<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;t&#39;</span>],
                   a<span style="color: #666666">=1</span>, w<span style="color: #666666">=</span>pi, x<span style="color: #666666">=2</span>)
</pre></div>
<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use string operations to extract the various parts of the string.
For example, the expression can be split out by calling
<code>split('is a function of')</code>.
Typically, you need to extract <code><expression></code>, <code><list1></code>,
and <code><list2></code>, and create a string like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">StringFunction(<span style="color: #666666">&lt;</span>expression<span style="color: #666666">&gt;</span>, independent_variables<span style="color: #666666">=</span>[<span style="color: #666666">&lt;</span>list1<span style="color: #666666">&gt;</span>],
               <span style="color: #666666">&lt;</span>list2<span style="color: #666666">&gt;</span>)
</pre></div>
<p>
and sending it to <code>eval</code> to create the object.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>text2func.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex8">Exercise 14: Compare average temperatures in cities<a name="sec:files:ex8"></a></h2>

The tarfile <a href="http://tinyurl.com/pwyasaa/misc/city_temp.tar.gz" target="_self"><tt>src/misc/city_temp.tar.gz</tt></a> contains a set of files with
temperature data for a large number of cities around the world. The
files are in text format with four columns, containing the month
number, the date, the year, and the temperature, respectively.
Missing temperature observations are represented by the value \( -99 \).
The mapping between the names of the text files and the names of the
cities are defined in an HTML file <code>citylistWorld.htm</code>.

<p>
<b>a)</b>
Write a function that can read the <code>citylistWorld.htm</code>
file and create a dictionary with mapping between city and filenames.

<p>
<b>b)</b>
Write a function that takes this dictionary and a city name
as input, opens the corresponding text file, and loads the data
into an appropriate data structure (dictionary of arrays and city name
is a suggestion).

<p>
<b>c)</b>
Write a function that can take a number of data
structures and the corresponding city names to create a plot of
the temperatures over a certain time period.

<p>
Filename: <code>temperature_data.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="sec:files:ex21">Exercise 15: Generate an HTML report with figures<a name="sec:files:ex21"></a></h2>

The goal of this exercise is to let a program write a report in HTML
format containing the solution to ref{sec:plot:ex5e}.  First,
include the program from that exercise, with additional explaining
text if necessary.  Program code can be placed inside <code><pre></code> and
<code></pre></code> tags.  Second, insert three plots of the \( f(x,t) \) function
for three different \( t \) values (find suitable \( t \) values that
illustrate the displacement of the wave packet).  Third, add an
animated GIF file with the movie of \( f(x,t) \).  Insert headlines
(<code><h1></code> tags) wherever appropriate.
Filename: <code>wavepacket_report.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="bioinf:exer:freq:fargs">Exercise 16: Allow different types for a function argument<a name="bioinf:exer:freq:fargs"></a></h2>

Consider the family of <code>find_consensus_v*</code> functions from
the section <a href="#bioinf:freq:analysis">Analyzing the frequency matrix</a>. The different versions work on
different representations of the frequency matrix. Make a unified
<code>find_consensus</code> function that accepts different data structures
for the <code>frequency_matrix</code>. Test on the type of data structure and
perform the necessary actions.
Filename: <code>find_consensus.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="bioinf:exer:get_base_counts2">Exercise 17: Make a function more robust<a name="bioinf:exer:get_base_counts2"></a></h2>

Consider the function <code>get_base_counts(dna)</code>
from the section <a href="#bioinf:basefreq">Finding base frequencies</a>,
which counts how many times <code>A</code>, <code>C</code>, <code>G</code>, and
<code>T</code> appears in the string <code>dna</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_base_counts</span>(dna):
    counts <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;A&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;T&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;G&#39;</span>: <span style="color: #666666">0</span>, <span style="color: #BA2121">&#39;C&#39;</span>: <span style="color: #666666">0</span>}
    <span style="color: #008000; font-weight: bold">for</span> base <span style="color: #AA22FF; font-weight: bold">in</span> dna:
        counts[base] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> counts
</pre></div>
<p>
Unfortunately, this function crashes if other letters appear in <code>dna</code>.
Write an enhanced function <code>get_base_counts2</code> which solves this problem.
Test it on a string like <code>'ADLSTTLLD'</code>.
Filename: <code>get_base_counts2.py</code>.

<p>
<!-- Hints: defaultdict or test on if base in counts: ... else counts[base]=1 -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="bioinf:exer:Ainsouts:exons">Exercise 18: Find proportion of bases inside/outside exons<a name="bioinf:exer:Ainsouts:exons"></a></h2>

Consider the lactase gene as described in
the sections <a href="#bioinf:gene2protein">Translating genes into proteins</a> and <a href="#bioinf:lactase:milk">Some humans can drink milk, while others cannot</a>.
What is the proportion of base A inside and outside exons of
the lactase gene?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Write a function <code>get_exons</code>, which returns
all the substrings of the exon regions concatenated.
Also write a function <code>get_introns</code>, which
returns all the substrings between the exon regions concatenated.
The function <code>get_base_frequencies</code> from the section <a href="#bioinf:basefreq">Finding base frequencies</a>
can then be used to analyze the frequencies of bases A, C, G, and T
in the two strings.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>prop_A_exons.py</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="___sec98">References <a name="___sec98"></a></h1>

<!-- begin bibliography -->

<ol>
 <li> <a name="Langtangen_TCSE6_funcif"></a> <b>H. P. Langtangen</b>. 
    Functions and branching,
    <a href="http://tcse6.on.net/funcif" target="_self"><tt>http://tcse6.on.net/funcif</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_input"></a> <b>H. P. Langtangen</b>. 
    User input and error handling,
    <a href="http://tcse6.on.net/input" target="_self"><tt>http://tcse6.on.net/input</tt></a>.</li>
 <li> <a name="Langtangen_TCSE6_varargs"></a> <b>H. P. Langtangen</b>. 
    Variable number of function arguments in Python,
    <a href="http://tcse6.on.net/varargs" target="_self"><tt>http://tcse6.on.net/varargs</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

